## Greedy and Non-greedy Matching
Because `(Ha){3,5}` can match three, four, or five instances of `Ha` in the string 'HaHaHaHaHa', you may wonder why the Match object’s call to `group()` in the previous curly bracket example returns 'HaHaHaHaHa' instead of the shorter possibilities. After all, 'HaHaHa' and 'HaHaHaHa' are also valid matches of the regular expression (Ha){3,5}.  

Python’s regular expressions are *greedy* by default, which means that in ambiguous situations, they will match the longest string possible. The *non-greedy* (also called lazy) version of the curly brackets, which matches the shortest string possible, must follow the closing curly bracket with a question mark.  

For example notice the difference between the greedy and non-greedy forms of the curly brackets searching the same string:
```python
import re

greedy_pattern = re.compile(r'(Ha){3,5}')
match1 = greedy_pattern.search('HaHaHaHaHa')
match1.group() # 'HaHaHaHaHa'

lazy_pattern = re.compile(r'(Ha){3,5} ?')
match2 = lazy_pattern.search('HaHaHaHaHa')
match2.group() # 'HaHaHa
```
**Note**
-  The question mark can have two meanings in regular expressions: declaring a lazy match or declaring an optional qualifier. These meanings are entirely unrelated.
-  It’s worth pointing out that, technically, you could get by without using the optional `?` quantifier, or even the `*` and `+` quantifiers:
    - The ? quantifier is the same as {0,1}.
    - The * quantifier is the same as {0,}.
    - The + quantifier is the same as {1,}.  

However, the `?`, `*`, and `+` quantifiers are common shorthand.

### Matching Everything:
Sometimes you may want to match everything and anything. For example, say you want to match the string `'First Name:'`, followed by any and all text, followed by `'Last Name:'` and any text once again. You can use the dot-star `(.*)` to stand in for that “anything.” Remember that the dot character means “any single character except the newline,” and the star character means “zero or more of the preceding character.” For example:
```python
import re

name_pattern = re.compile(r'First Name: (.*) Last Name: (.*)')
name_match = name_pattern.search('First Name: Al Last Name: Sweigart')

name_match.group(1) #  'Al'
name_match.group(2) # 'Sweigart
```
The dot-star uses *greedy* mode: it will always try to match as much text as possible. To match any and all text in a *non-greedy* or *lazy* fashion, use the dot, star, and question mark `(.*?)`. As when it’s used with curly brackets, the question mark tells Python to match in a non-greedy way. For example:
```python
import re

lazy_pattern = re.compile(r'< .* ?>')
match1 = lazy_pattern.search('<To serve man> for dinner.>')
match1.group() # '<To serve man>'

greedy_re = re.compile(r'< .*>')
match2 = greedy_re.search('<To serve man> for dinner.>')
match2.group() # '<To serve man> for dinner.>'
```
Both regexes roughly translate to “Match an opening angle bracket, followed by anything, followed by a closing angle bracket.” But the string `'<To serve man> for dinner.>'` has two possible matches for the closing angle bracket. In the non-greedy version of the regex, Python matches the shortest possible string: `'<To serve man>'`. In the greedy version, Python matches the longest possible string: `'<To serve man> for dinner.>'`.  

###  Matching Newline Characters:
The dot in `.*` will match everything except a newline. By passing `re.DOTALL` as the second argument to `re.compile()`, you can make the dot character match all characters, including the newline character. For example:
```python
import re

no_newline_re = re.compile(' .*')
no_newline_re.search('Serve the public trust.\nProtect the innocent. \nUphold the law.').group() # 'Serve the public trust.'

newline_re = re.compile(' .*', re.DOTALL)
newline_re.search('Serve the public trust.\nProtect the innocent. \nUphold the law.').group()
# 'Serve the public trust.\nProtect the innocent.\nUphold the law.'
```
The regex `no_newline_re`, which did not have `re.DOTALL` passed to the  `re.compile()` call that created it, will match everything only up to the first newline character, whereas `newline_re`, which *did* have `re.DOTALL` passed to `re.compile()`, matches everything. This is why the `newline_re.search()` call matches the full string, including its newline characters.

## Matching at the Start and End of a String:
You can use the caret symbol `^` at the start of a regex to indicate that a match must occur at the beginning of the searched text. Likewise, you can put a dollar sign `$` at the end of the regex to indicate that the string must end with this regex pattern. And you can use the `^` and `$` together to indicate that the entire string must match the regex—that is, it’s not enough for a match to be made on some subset of the string.  
For example, the `r'^Hello'` regular expression string matches strings that begin with 'Hello':
```python
import re

begins_with_hello = re .compile(r'^Hello')

begins_with_hello.search('Hello, world!')
<re.Match object; span=(0, 5), match='Hello'>

begins_with_hello.search('He said "Hello."') == None # True
```
The `r'\d$'` regular expression string matches strings that end with a numeric character between 0 and 9. For example:
```python
import re

ends_with_number = re .compile(r'\d$')

ends_with_number.search('Your number is 42')
<re.Match object; span=(16, 17), match='2'>

ends_with_number.search('Your number is forty two.') == None # True
```
The `r'^\d+$'` regular expression string matches strings that both begin and end with one or more numeric characters. For example:
```python
import re

whole_string_is_num = re .compile(r'^\d+$')

whole_string_is_num.search('1234567890')
<re.Match object; span=(0, 10), match='1234567890'>

whole_string_is_num.search('12345xyz67890') == None # True
```
The last two search() calls in the previous example demonstrates how the entire string must match the regex if `^` and `$` are used. To check if a string starts and ends with digits, but has other characters in between you use the regular expression `r'^\d.*\d$'`, where `.*` represents any characters (zero or more).  

You can also use `\b` to make a regex pattern match only on a word boundary: the start of a word, end of a word, or both the start and end of a word. In this case, a “word” is a sequence of letters separated by non-letter characters. For example, `r'\bcat.*?\b'` matches a word that begins with 'cat' followed by any other characters up to the next word boundary:
```python
import re

pattern = re .compile(r'\bcat .* ?\b')
pattern.findall('The cat found a catapult catalog in the catacombs.')
# ['cat', 'catapult', 'catalog', 'catacombs']
```
The `\B` syntax matches anything that is not a word boundary:
```python
import re

pattern = re .compile(r'\Bcat\B')
pattern.findall('certificate')  # Match => ['cat']
pattern.findall('catastrophe')  # No match => []
```
It is useful for finding matches in the middle of a word.

## Case-insensitive Matching
Normally, regular expressions match text with the exact casing you specify. For example, the following regexes match completely different strings:
```python
import re

pattern1 = re.compile('RoboCop')
pattern2 = re.compile('ROBOCOP')
pattern3 = re.compile('robOcop')
pattern4 = re.compile('RobocOp')
```
But sometimes you care only about matching the letters, and aren’t worried about whether they’re uppercase or lowercase. To make your regex case-insensitive, you can pass `re.IGNORECASE` or `re.I` as a second argument to `re.compile()`.
```python
import re

pattern = re .compile(r'robocop', re.I)
pattern.search('RoboCop is part man, part machine, all cop.').group() # 'RoboCop'

pattern.search('ROBOCOP protects the innocent.').group() # 'ROBOCOP'

pattern.search('Have you seen robocop?').group() # 'robocop'
```
The regular expression now matches strings with any casing.

##  Substituting Strings
Regular expressions don’t merely find text patterns; they can also substitute new text in place of those patterns. The `sub()` method for Pattern objects accepts two arguments. The first is a string that should replace any matches. The second is the string of the regular expression. The `sub()` method returns a string with the substitutions applied.  
For example, the following script will replace secret agents’ names with CENSORED:
```python
import re

agent_pattern = re .compile(r'Agent \w+')
agent_pattern.sub('CENSORED', 'Agent Alice contacted Agent Bob.')
# 'CENSORED contacted CENSORED.'
```
Sometimes you may need to use the matched text itself as part of the substitution. In the first argument to `sub()`, you can include `\1`, `\2`, `\3`, and so on, to mean “Enter the text of group 1, 2, 3, and so on, in the substitution.” 
This syntax is called a *back reference*.  
For example, say you want to censor the names of the secret agents by showing just the first letters of their names. To do this, you could use the regex Agent `(\w)\w*` and pass `r'\1****'` as the first argument to `sub()`:
```python
import re

agent_pattern = re .compile(r'Agent (\w)\w*')

agent_pattern.sub(r'\1****', 'Agent Alice contacted Agent Bob.') # 'A**** contacted B****.'
```
The `\1` in the regular expression string is replaced by whatever text was matched by group `1—` that is, the `(\w)` group of the regular expression.

##  Managing Complex Regexes with Verbose Mode
Regular expressions are fine if the text pattern you need to match is simple. But matching complicated text patterns might require long, convoluted regular expressions. You can mitigate this complexity by telling the `re.compile()` function to ignore whitespace and comments inside the regular expression string. Enable this “verbose mode” by passing the variable `re.VERBOSE` as the second argument to `re.compile()`.  
Now, instead of a hard-to-read regular expression like this:
```python
pattern = re .compile(r'((\d{3}|\(\d{3}\)) ?(\s| -|\ .) ?\d{3}(\s|-|\.)\d{4}(\s*(ext|x|ext\.)\s*\d{2,5})?)')
```
