## Greedy and Non-greedy Matching
Because `(Ha){3,5}` can match three, four, or five instances of `Ha` in the string 'HaHaHaHaHa', you may wonder why the Match object’s call to `group()` in the previous curly bracket example returns 'HaHaHaHaHa' instead of the shorter possibilities. After all, 'HaHaHa' and 'HaHaHaHa' are also valid matches of the regular expression (Ha){3,5}.  

Python’s regular expressions are *greedy* by default, which means that in ambiguous situations, they will match the longest string possible. The *non-greedy* (also called lazy) version of the curly brackets, which matches the shortest string possible, must follow the closing curly bracket with a question mark.  

For example notice the difference between the greedy and non-greedy forms of the curly brackets searching the same string:
```python
import re

greedy_pattern = re.compile(r'(Ha){3,5}')
match1 = greedy_pattern.search('HaHaHaHaHa')
match1.group() # 'HaHaHaHaHa'

lazy_pattern = re.compile(r'(Ha){3,5} ?')
match2 = lazy_pattern.search('HaHaHaHaHa')
match2.group() # 'HaHaHa
```
**Note**
-  The question mark can have two meanings in regular expressions: declaring a lazy match or declaring an optional qualifier. These meanings are entirely unrelated.
-  It’s worth pointing out that, technically, you could get by without using the optional `?` quantifier, or even the `*` and `+` quantifiers:
    - The ? quantifier is the same as {0,1}.
    - The * quantifier is the same as {0,}.
    - The + quantifier is the same as {1,}.  

However, the `?`, `*`, and `+` quantifiers are common shorthand.

### Matching Everything:
Sometimes you may want to match everything and anything. For example, say you want to match the string `'First Name:'`, followed by any and all text, followed by `'Last Name:'` and any text once again. You can use the dot-star `(.*)` to stand in for that “anything.” Remember that the dot character means “any single character except the newline,” and the star character means “zero or more of the preceding character.” For example:
```python
import re

name_pattern = re.compile(r'First Name: (.*) Last Name: (.*)')
name_match = name_pattern.search('First Name: Al Last Name: Sweigart')

name_match.group(1) #  'Al'
name_match.group(2) # 'Sweigart
```
The dot-star uses *greedy* mode: it will always try to match as much text as possible. To match any and all text in a *non-greedy* or *lazy* fashion, use the dot, star, and question mark `(.*?)`. As when it’s used with curly brackets, the question mark tells Python to match in a non-greedy way. For example:
```python
import re

lazy_pattern = re.compile(r'< .* ?>')
match1 = lazy_pattern.search('<To serve man> for dinner.>')
match1.group() # '<To serve man>'

greedy_re = re.compile(r'< .*>')
match2 = greedy_re.search('<To serve man> for dinner.>')
match2.group() # '<To serve man> for dinner.>'
```
Both regexes roughly translate to “Match an opening angle bracket, followed by anything, followed by a closing angle bracket.” But the string `'<To serve man> for dinner.>'` has two possible matches for the closing angle bracket. In the non-greedy version of the regex, Python matches the shortest possible string: `'<To serve man>'`. In the greedy version, Python matches the longest possible string: `'<To serve man> for dinner.>'`.  

###  Matching Newline Characters:
The dot in `.*` will match everything except a newline. By passing `re.DOTALL` as the second argument to `re.compile()`, you can make the dot character match all characters, including the newline character. For example:
```python
import re

no_newline_re = re.compile(' .*')
no_newline_re.search('Serve the public trust.\nProtect the innocent. \nUphold the law.').group() # 'Serve the public trust.'

newline_re = re.compile(' .*', re.DOTALL)
newline_re.search('Serve the public trust.\nProtect the innocent. \nUphold the law.').group()
# 'Serve the public trust.\nProtect the innocent.\nUphold the law.'
```
The regex `no_newline_re`, which did not have `re.DOTALL` passed to the  `re.compile()` call that created it, will match everything only up to the first newline character, whereas `newline_re`, which *did* have `re.DOTALL` passed to `re.compile()`, matches everything. This is why the `newline_re.search()` call matches the full string, including its newline characters.

## Matching at the Start and End of a String
You can use the caret symbol `^` at the start of a regex to indicate that a match must occur at the beginning of the searched text. Likewise, you can put a dollar sign `$` at the end of the regex to indicate that the string must end with this regex pattern. And you can use the `^` and `$` together to indicate that the entire string must match the regex—that is, it’s not enough for a match to be made on some subset of the string.
