## REGULAR EXPRESSIONS
We recognize all sorts of other text patterns every day: email addresses have @ symbols in the middle, US Social Security numbers have nine digits and two hyphens, website URLs often have periods and forward slashes, news headlines use title case, and social media hashtags begin with # and contain no spaces, to give some examples. ***Regular expressions*** allow you to specify a pattern of text.  

Regular expressions are helpful, but few nonprogrammers know about them, even though most modern text editors and word processors have find-and-replace features that can search based on regular expressions.They are huge time-savers, not just for software users but also for programmers.

Tech writer Cory Doctorow argues:  
> "Knowing regular expressions can mean the difference between solving a problem in 3 steps and solving it in 3,000 steps. When you’re a nerd, you forget that the problems you solve with a couple keystrokes can take other people days of tedious, error-prone work to slog through."

### Finding Text Patterns Without Regular Expressions:
Say you want to find a US phone number in a string; you’re looking for three numbers, a hyphen, three numbers, a hyphen, and four numbers. Here’s an example: 415-555-4242.
Let’s write a function to check whether a string matches this pattern and return either `True` or `False`.
```python
def isPhoneNumber(text):
    if len(text) != 12:
        return False
    
    for i in range(0,3):
        if not text[i].isdecimal():
            return False
        
    if text[3] != '-':
        return False
    
    for i in range(4,7):
        if not text[i].isdecimal():
            return False
        
    if text[7] != '-':
        return False
    
    for i in range(8,12):
        if not text[i].isdecimal():
            return False
        
    return True

print('Is 415-555-4242 a phone number?')
print(is_phone_number('415-555-4242'))
print('Is Moshi moshi a phone number?')
print(is_phone_number('Moshi moshi'))
```
When this program is run, the output looks like this:
```txt
Is 415-555-4242 a phone number?
True
Is Moshi moshi a phone number?
False
```
If you wanted to find a phone number within a larger string, you would have to add even more code to locate the pattern.
```python
def isPhoneNumber(text):
    if len(text) != 12:
        return False
    
    for i in range(0,3):
        if not text[i].isdecimal():
            return False
        
    if text[3] != '-':
        return False
    
    for i in range(4,7):
        if not text[i].isdecimal():
            return False
        
    if text[7] != '-':
        return False
    
    for i in range(8,12):
        if not text[i].isdecimal():
            return False
        
    return True

message = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.'
for i in range(len(message)):
    segment = message[i:i+12]
    if isPhoneNumber(segment):
        print('Phone number found: ' + segment)
print('Done')
```
When this program is run, the output will look like this:
```txt
Phone number found: 415-555-1011
Phone number found: 415-555-9999
Done
```
On each iteration of the for loop, a new segment of 12 characters from message is assigned to the variable `segment`. The loop’s code passes segment to `isPhoneNumber()` to check whether it matches the phone number pattern, and if so, it prints the `segment`. Once it has finished going through `message`, we print `Done`.

### Finding Text Patterns with Regular Expressions:
The previous phone number–finding program works, but it uses a lot of code to do something limited. The `isPhoneNumber()` function has several lines but can find only one phone number format. What about a phone number formatted like 415.555.4242 or (415) 555-4242? And what if the phone number had an extension, like 415-555-4242 x99? The `isPhoneNumber()` function would fail to find them. You could add yet more code for these additional patterns, but there is an easier way to tackle the problem.  

Regular expressions, called *regexes* for short, are a sort of mini language that describes a pattern of text. For example, the characters `\d` in a regex stand for a decimal numeral between 0 and 9. Python uses the regex string `r'\d\d\d-\d\d\d-\d\d\d\d'` to match the same text pattern the previous `isPhoneNumber()` function did: a string of three numbers, a hyphen, three more numbers, another hyphen, and four numbers. Any other string would not match the `r'\d\d\d-\d\d\d-\d\d\d\d'` regex.  

Regular expressions can be much more sophisticated than this one. For example, adding a numeral, such as 3, in curly brackets ({3}) after a pattern is like saying, “Match this pattern three times.” So the slightly shorter regex `r'\d{3}-\d{3}-\d{4}'` also matches the phone number pattern.  

Note that we often write regex strings as raw strings, with the `r` prefix. This is useful, as regex strings often have backslashes. Without using raw strings, we would have to enter expressions such as `'\\d'`.

The general process of using regular expressions in Python involves four steps:
 1. Import the `re` module.
 2. Pass the regex string to `re.compile()` to get a Pattern object.
 3. Pass the text string to the Pattern object’s `search()` method to get a Match object.
 4. Call the Match object’s `group()` method to get the string of the matched text.

##### Example:
```python
import re # Import the 're' module for working with regular expressions

phone_num_pattern_obj = re.compile(r'\d{3}-\d{3}-\d{4}')
match_obj = phone_num_pattern_obj.search('My number is 415-555-4242.')

print(match_obj.group())

# 415-555-4242
```
All regex functions in Python are in the `re` module, so remember to import it at the beginning of the program. Otherwise, you’ll get a `NameError: name 're' is not defined` error message.  

Passing the regular expression string to `re.compile()` returns a Pattern object. You only need to compile the Pattern object once; after that, you can call the Pattern object’s `search()` method for as many different text strings as you want.  
A Pattern object’s `search()` method searches the string it is passed for any matches to the regex. The `search()` method will return `None` if the regex pattern isn’t found in the string. If the pattern is found, the `search()` method returns a `Match` object, which will have a `group()` method that returns a string of the matched text.

## A REVIEW OF REGEX SYMBOLS
Here’s a quick review of the basic regular expression syntax:
- The `?` matches zero or one instance of the preceding qualifier .
- The `*` matches zero or more instances of the preceding qualifier .
- The `+` matches one or more instances of the preceding qualifier .
- The `{n}` matches exactly *n* instances of the preceding qualifier .
- The `{n,}` matches *n* or more instances of the preceding qualifier .
- The `{,m}` matches 0 to *m* instances of the preceding qualifier .
- `^spam` means the string must begin with *spam* .
- The `{n,m}` matches at least *n* and at most *m* instances of the preceding qualifier .
- `{n,m}?` or `*?` or `+?` performs a non-greedy match of the preceding qualifier .
- `spam$` means the string must end with *spam* .
- The `.` matches any character, except newline characters .
- The `\d`, `\w`, and `\s` match a digit, word, or space character, respectively .
- The `\D`, `\W`, and `\S` match anything except a digit, word, or space character, respectively . `[abc]` matches any character between the square brackets (such as a, b, or c) .
- `[^abc]` matches any character that isn’t between the square brackets .
- `(Hello)` groups `'Hello'` together as a single qualifier 
