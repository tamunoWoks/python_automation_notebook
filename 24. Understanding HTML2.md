### Controlling the Browser with Selenium
Selenium lets Python directly control the browser by programmatically clicking links and filling in forms, just as a human user would. Using Selenium, you can interact with web pages in a much more advanced way than with requests and Beautiful Soup; but because it launches a web browser, it’s a bit slower and hard to run in the background.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Still, if you need to interact with a web page in a way that, for instance, depends on the JavaScript code that updates the page, you’ll need to use Selenium instead of requests. That’s because major e-commerce websites such as Amazon almost certainly have software systems to recognize traffic that they suspect is a script harvesting their info or signing up for multiple free accounts. These sites may refuse to serve pages to you after a while, breaking any scripts you’ve made. Selenium is much more likely than requests to function on these sites long term.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A major “tell” to websites that you’re using a script is the user-agent string, which identifies the web browser and is included in all HTTP requests. For example, the user-agent string for the requests module is something like `'python-requests/X.XX.X'`. You can visit a site such as _https://www.whatsmyua.info_ to see your user-agent string. Using Selenium, you’re much more likely to pass for human, because not only is Selenium’s user agent the same as a regular browser (for instance, `'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0')`, but it has the same traffic patterns: a Selenium-controlled browser will download images, advertisements, cookies, and privacy-invading trackers just like a regular browser. However, websites can still find ways to detect Selenium, and major ticketing and e-commerce websites often block it to prevent the web scraping of their pages.

#### Starting a Selenium-Controlled Browser:
The following examples will show you how to control Firefox’s web browser. If you don’t already have Firefox, you can download it for free from _https://getfirefox.com_.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Importing Selenium’s modules is slightly tricky. Instead of `import selenium`, you must run **`from selenium import webdriver`**. After that, you can launch the Firefox browser with Selenium. Enter the following into the interactive shell:
```python
from selenium import webdriver

browser = webdriver.Firefox()
type(browser)
<class 'selenium.webdriver.firefox.webdriver.WebDriver'>
browser.get('https://inventwithpython.com')
```
You’ll notice that when `webdriver.Firefox()` is called, the Firefox web browser starts up. Calling `type()` on the value `webdriver.Firefox()` reveals it’s of the WebDriver data type. And calling `browser.get('https://inventwithpython.com')` directs the browser to _https://inventwithpython.com_.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you encounter the error message “geckodriver executable needs to be in PATH,” you need to manually download the web driver for Firefox before you can use Selenium to control it. You can also control browsers other than Firefox if you install the web driver for them, and instead of manually downloading browser web drivers, you can use the webdriver-manager package from _https://pypi.org/project/webdriver-manager/_.
#### Clicking Browser Buttons:
Selenium can simulate clicks on various browser buttons through the following methods:
- **`browser.back()`:** Clicks the Back button
- **`browser.forward()`:** Clicks the Forward button
- **`browser.refresh()`:** Clicks the Refresh/Reload button
- **`Browser.quit()`:** Clicks the Close Window button
#### Finding Elements on the Page:
A `WebDrive`r object has the `find_element(`) and `find_elements()` methods for finding elements on a web page. The `find_element()` method returns a single `WebElement` object, representing the first element on the page that matches your query. The `find_elements()` method returns a list of `WebElement` objects for every matching element on the page.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can find elements through their class name, CSS selector, ID, or another means. First, run `from selenium.webdriver.common.by import By` to get the `By` object. The `By` object has several constants you can pass to the `find_element()` and `find_elements()` methods.  

**Selenium’s By Constants for Finding Elements:**
| Constant name          |  WebElement object/list returned                                                               |
|:-----------------------|:-----------------------------------------------------------------------------------------------|
| `By.CLASS_NAME`        | Elements that use the CSS class name                                                           |
| `By.CSS_SELECTOR`      | Elements that match the CSS selector                                                           |
| `By.ID`                | Elements with a matching id attribute value                                                    |
| `By.LINK_TEXT`         | <a> elements that completely match the text provided                                           |
| `By.PARTIAL_LINK_TEXT` | <a> elements that contain the text provided                                                    |
| `By.NAME`              | Elements with a matching name attribute value                                                  |
| `By.TAG_NAME`          | Elements with a matching tag name (case-insensitive; an <a> element is matched by 'a' and 'A') |

If no elements exist on the page that match what the method is looking for, Selenium raises a `NoSuchElement` exception. If you do not want this exception to crash your program, add `try` and `except` statements to your code.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Once you have the `WebElement` object, you can learn more about it by reading the attributes or calling the methods below.

**WebElement Attributes and Methods:**
| Attribute or method   |   Description                                                                                                                                                                                            |
|:----------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `tag_name`            | The tag name, such as 'a' for an <a> element                                                                                                                                                             |
| `get_attribute(name)` |  The value for the element’s name attribute, like href in an <a> element                                                                                                                                 |
| `get_property(name)`  | The value for the element’s property, which does not appear in the HTML code . Some examples of HTML properties are innerHTML and innerText                                                              |
| `text`                |  The text within the element, such as 'hello' in the following: <span>hello</span>                                                                                                                       |
| `clear()`             |  For text field or text area elements, clears the text entered  into it                                                                                                                                  |
| `is_displayed()`      | Returns True if the element is visible; otherwise, returns False                                                                                                                                         |
| `is_enabled()`        |  For input elements, returns True if the element is enabled; otherwise, returns False                                                                                                                    |
| `is_selected()`       | Elements with a matching tag name (case-insensitive; an <a> element is matched by 'a' and 'A') For checkbox or radio button elements, returns True if the element is selected; otherwise, returns False  |
| `location`            |  A dictionary with keys 'x' and 'y' for the position of the element in the page                                                                                                                          |
| `size`                |  A dictionary with keys 'width' and 'height' for the size of the element in the page                                                                                                                     |
For example:
```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Firefox()
browser.get('https://autbor.com/example3.html')
elems = browser.find_elements(By.CSS_SELECTOR, 'p')
print(elems[0].text)
print(elems[0].get_property('innerHTML'))
```
Here, we open Firefox and direct it to a URL. On this page, we get a list of the `<p>` elements, look at the first one at index 0, and then get the string of the text inside that `<p`> element. Next, we get the string of its `innerHTML` property. This program outputs the following:
```txt
This <p> tag puts content into a single paragraph.
This &lt;p&gt; tag puts <b>content</b> into a <i>single</i> paragraph.
```
The element’s text attribute shows the text as we’d see it in the web browser: “This <p> tag puts content into a single paragraph.” We can also examine the element’s `innerHTM`L property by calling the `get_property()` method, which is the HTML source code that includes tags and HTML entities. (The &lt; and &gt; are HTML escape characters that represent the less than [<] and greater than [>] characters.)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that the `text` attribute is just a shortcut for calling `get_property('inner Text')`. The names _innerHTML_ and _innerText_ are standard names of properties for HTML elements. In short, these element properties are accessed by JavaScript code and web drivers, while element attributes are part of the HTML source code, like the `href` in `<a href ="https://inventwithpython.com">`.

### Clicking Elements on the Page:
The `WebElement` objects returned from the `find_element()` and `find_elements()` methods have a `click()` method that simulates a mouse click on that element. This method can be used to follow a link, make a selection on a radio button, click a Submit button, or trigger whatever else might happen when a mouse clicks the element. For example:
```python
from selenium import webdriver
from selenium .webdriver .common .by import By

browser = webdriver.Firefox()
browser .get('https://autbor .com /example3 .html')
link_elem = browser.find_element(By.LINK_TEXT, 'This text is a link')
type(link_elem)
<class 'selenium.webdriver.remote.webelement.WebElement'>
link_elem.click()  # Follows the "This text is a link" link
```
This code opens Firefox to `https://autbor.com example3.html`, gets the `WebElement` object for the `<a>` element with the text _This is a link_, and then simulates clicking that `<a>` element as if you’d clicked the link yourself; the browser then follows that link.
### Filling Out and Submitting Forms:
Sending keystrokes to text fields on a web page is a matter of finding the `<input>` or `<textarea>` element for that text field and then calling the `send_keys()` method. For example:
```
from selenium import webdriver
from selenium .webdriver .common .by import By

browser = webdriver.Firefox()
browser.get('https://autbor.com/example3.html')
user_elem = browser.find_element(By.ID, 'login_user')
user_elem.send_keys('your_real_username_here')
password_elem = browser.find_element(By.ID, 'login_pass')
password_elem.send_keys('your_real_password_here')
password_elem.submit()
```
As long as the login page hasn’t changed the `id` of the username and password `<input>` elements, the previous code will fill in those text fields with the provided text. (You can always use the browser’s inspector to verify the `id`.) Calling the `submit()` method on any element will have the same result as clicking the Submit button for the form that element is in. (You could have just as easily called `user_elem.submit()`, and the code would have done the same thing.)
