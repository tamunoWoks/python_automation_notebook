##  The File Reading and Writing Process
Once you’re comfortable working with folders and relative paths, you’ll be able to specify the locations of files to read and write. The functions covered in the next few sections apply to plaintext files. Plaintext files contain only basic text characters and do not include font, size, or color information. Text files with the `.txt` extension or Python script files with the `.py` extension are examples of plaintext files. You can open these with the Windows Notepad or macOS TextEdit application, and your programs can easily read their content, then treat it as an ordinary string value.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary files are all other file types, such as word processing documents, PDFs, images, spreadsheets, and executable programs. If you open a binary file in Notepad or TextEdit, it usually looks like scrambled nonsense.  

We must handle each type of binary file in its own way. Fortunately, many modules make working with binary files easier, and we’ll explore one of them, the `shelve` module later.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `pathlib` module’s `read_text()` method returns the full contents of a text file as a string. Its `write_text()` method creates a new text file (or overwrites an existing one) with the string passed to it. For example:
```
from pathlib import Path

p = Path('spam.txt')

p.write_text('Hello, world!') # 13
p.read_text() # 'Hello, world!'
```
These method calls create a `spam.txt` file with the content `'Hello, world!'`. The 13 that `write_text()` returns indicates that 13 characters were written to the file. (You can often disregard this return value.) The `read_text()` call reads and returns the contents of the new file as a string: 'Hello, world!'.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Keep in mind that these `Path` object methods allow only basic interactions with files. The more common way of writing to a file involves using the `open()` function and file objects. There are three steps to reading or writing f iles in Python:
  1. Call the `open()` function to return a File object.
  2. Call the `read()` or `write()` method on the File object.
  3. Close the file by calling the `close()` method on the File object.  

Note that as you begin working with files, you may find it helpful to be able to quickly see their extensions (`.txt`, `.pdf`, `.jpg`, and so on). Windows and macOS may hide file extensions by default, showing `spam.txt` as simply `spam`. To show extensions, open the settings for File Explorer (on Windows) or Finder (on macOS) and look for a checkbox that says something like “Show all filename extensions” or “Hide extensions for known file types.” (The exact location and wording of this setting depend on the version of your operating system.

### Opening Files:
To open a file with the `open()` function, pass it a string path indicating the file you want to open. This can be either an absolute path or a relative path. The `open()` function returns a File object.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Try this by creating a text file named *hello.txt* using Notepad or TextEdit. Enter Hello, world! as the content of this text file and save it in your user home folder. Then, enter the following code:
```python
from pathlib import Path

hello_file = open(Path.home() / 'hello.txt', encoding='UTF-8')
```
The `open()` function will open the file in “reading plaintext” mode, or *read mode* for short. When a file is opened in read mode, Python lets you read the file’s data but not write or modify it in any way. Read mode is the default mode for files you open in Python. But if you don’t want to rely on Python’s defaults, you can explicitly specify the mode by passing the string value `'r'` as a second argument to `open` For example, `open('/Users/Al/ hello.txt', 'r')` does the same thing as open('/Users/Al/hello.txt').  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The encoding named parameter specifies what encoding to use when converting the bytes in the file to a Python text string. The correct encoding is almost always `'utf-8'`, which is also the default encoding used on macOS and Linux. However, Windows uses   'cp1252'   for its default encoding (also known as extended ASCII). This can cause problems when trying to read certain UTF-8 encoded text files with non-English characters on Windows, so it’s a good habit to pass `encoding='utf-8'` to your `open()` function calls when opening files in plaintext read, write, or append mode. The binary read, write, and append modes don’t use the encoding named parameter, so you can leave it out in those cases.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The call to `open()` returns a File object. A File object represents a file on your computer; it is simply another type of value in Python, much like the lists and dictionaries. In the previous example, we stored the File object in the variable `hello_file`. Now, whenever you we want to read from or write to the file, we can do so by calling methods on the File object in `hello_file`.

### Reading the Contents of Files:
Now that we have a File object, we can start reading from it. If you want to read the entire contents of a file as a string value, use the File object’s `read()` method. Let’s continue with the *hello.txt* File object you stored in `hello_file`. 
```python
hello_content = hello_file.read()
hello_content # 'Hello, world!'
```
You can think of the contents of a file as a single large string value; the `read()` method merely returns the string that is stored in the file. Alternatively, you can use the `readlines()` method to get a list of string values from the file, one for each line of text. For example, create a file named *sonnet29.txt* in the same directory as *hello.txt* and place the following text in it:
```txt
 When, in disgrace with fortune and men's eyes,
 I all alone beweep my outcast state,
 And trouble deaf heaven with my bootless cries,
 And look upon myself and curse my fate,
```
Make sure to separate the four lines with line breaks. Then, enter the following:
```python
sonnet_file = open(Path.home() / 'sonnet29.txt', encoding='UTF-8')
sonnet_file.readlines() # ["When, in disgrace with fortune and men's eyes,\n", 'I all alone beweep my outcast state,\n', And trouble deaf heaven with my bootless cries,\n', 'And look upon myself and curse my fate,']
```
Note that, except for the last line of the file, each of the string values ends with a newline character `\n`. A list of strings is often easier to work with than a single large string value.

### Writing to Files:
Python allows you to write content to a file, just as the `print()` function writes strings to the screen. You can’t write to a file you’ve opened in read mode, though. Instead, you need to open it in “write plaintext” mode or “append plaintext” mode, called *write mode* and *append mode* for short.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write mode will overwrite the existing file, which is similar to overwriting a variable’s value with a new value. Pass `'w'` as the second argument to `open()` to open the file in write mode. Append mode, on the other hand, will append text to the end of the existing file. You can think of this mode as appending values to a list in a variable rather than overwriting the variable altogether. Pass `'a'` as the second argument to open() to open the file in append mode.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the filename passed to `open()` does not exist, both write mode and append mode will create a new, blank file. After reading or writing a file, call the `close()` method before opening the file again.
 Let’s put these concepts together:
```python
bacon_file = open('bacon.txt', 'w', encoding='UTF-8')   

bacon_file.write('Hello, world!\n') # 14
bacon_file.close()
bacon_file = open('bacon.txt', 'a', encoding='UTF-8')

bacon_file.write('Bacon is not a vegetable.') # 25
bacon_file.close()
bacon_file = open('bacon.txt', encoding='UTF-8')

content = bacon_file.read()
bacon_file.close()
print(content)
# Hello, world!
# Bacon is not a vegetable.
```
First, we open `bacon.txt` in write mode. As no `bacon.txt` file exists yet, Python creates one. Calling `write()` on the opened file and passing `write()` the string argument `'Hello, world!\n'` writes the string to the file and returns the number of characters written, including the newline. Then, we close the file.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To add text to the existing contents of the file instead of replacing the string we just wrote, we open the file in append mode. We write `'Bacon is not a vegetable.'` to the file and close it. Finally, to print the file contents to the screen, we open the file in its default read mode, call `read()`, store the 
resulting File object in content, close the file, and print content.  
**Note:**  
The `write()` method does not automatically add a newline character to the end of the string like the `print()` function does. You will have to add this character yourself. You can also pass a `Path` object to the `open()` function instead of the file name as a string.

### Using with Statements:
Every file on which your program calls `open()` needs `close()` called on it as well, but you may forget to include the `close()` function, or your program might skip over the `close()` call in certain circumstances.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python’s `with` statement makes it easier to automatically close files. A with statement creates something called a context manager that Python uses to manage resources. These resources, such as files, network connections, or segments of memory, often have setup and teardown steps during which the resource is allocated and later released so that other programs can make use of it. (Most of the time, however, you’ll encounter with statements used to open files.)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `with` statement adds a block of code that begins by allocating the resource and then releases it when the program execution leaves the block, which could happen due to a return statement, an unhandled exception being raised, or some other reason.  Here is typical code that writes and reads the content of a file:
```python
file_obj = open('data.txt', 'w', encoding='utf-8')
file_obj.write('Hello, world!')
file_obj.close()
file_obj = open('data.txt', encoding='utf-8')
content = file_obj.read()
file_obj.close()
```
Here is the equivalent code using a with statement:
```python
with open('data.txt', 'w', encoding='UTF-8') as file_obj:
    file_obj.write('Hello, world!')
with open('data.txt', encoding='UTF-8') as file_obj:
    content = file_obj.read()
```
In the `with` statement example, notice that there are no calls to `close()` at all because the `with` statement utomatically calls it when the program execution leaves the block. The `with` statement knows to do this based on the context manager it obtains from the `open()` function.

## Saving Variables with the shelve Module
You can save variables in your Python programs to binary shelf files using the `shelve` module. This lets your program restore that data to the variables the next time it is run. You could use this technique to add Save and Open features to your program; for example, if you ran a program and entered some configuration settings, you could save those settings to a shelf file and then have the program load the settings the next time it is run.
```python
import shelve

shelf_file = shelve.open('mydata')
shelf_file['cats'] = ['Zophie', 'Pooka', 'Simon']
shelf_file.close()
```
To read and write data using the `shelve`module, you first import `shelve`. Next, call `shelve.open()` and pass it a filename, then store the returned shelf value in a variable. You can make changes to the shelf value as if it were a dictionary. When you’re done, call `close()` on the shelf value. Here, our shelf value is stored in `shelf_file`. We create a list cats and write `shelf_file['cats'] = ['Zophie', 'Pooka', 'Simon']` to store the list in `shelf_file` as a value associated with the key `'cats'` (like in a dictionary). Then, we call `close()` on `shelf_file`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After running the previous code on Windows, you should see three new files in the current working directory: `mydata.bak`, `mydata.dat`, and `mydata.dir`. On macOS, you should see only a single `mydata.db` file, and Linux has a single `mydata` file. These binary files contain the data you stored in your shelf. The format of these binary files isn’t important; you only need to know what the `shelve` module does, not how it does it. The module frees you from worrying about how to store your program’s data to a file.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Your programs can use the `shelve` module to later reopen and retrieve the data from these shelf files. Shelf values don’t have to be opened in read or write mode; they allow both reading and writing once opened. For example:
```python
shelf_file = shelve.open('mydata')
type(shelf_file) # <class 'shelve.DbfilenameShelf'>
shelf_file['cats'] # ['Zophie', 'Pooka', 'Simon']
shelf_file.close()
```
Here, we open the shelf files to check that they stored the data correctly. Entering `shelf_file['cats']` returns the same list we created earlier. Now that we know the file stored the list correctly, we call `close()`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just like dictionaries, shelf values have `keys()` and `values()` methods that will return list-like values of the keys and values in the shelf. Because these return values are not true lists, you should pass them to the `list()` function to get them in list form. For example:
```python
shelf_file = shelve.open('mydata')
list(shelf_file.keys()) # ['cats']
list(shelf_file.values()) # [['Zophie', 'Pooka', 'Simon']]
shelf_file.close()
```
Plaintext is useful for creating files that you’ll read in a text editor such as Notepad or TextEdit, but if you want to save data from your Python programs, use the shelve module.
