## The Syntax of Regular Expressions
Let's learn how to group regular expression elements together with parentheses, escape special characters, match several alternative groups with the pipe character, and return all matches with the `findall()` method.

### Grouping with Parentheses:
Say you want to separate one smaller part of the matched text, such as the area code, from the rest of the phone number (to, for example, perform some operation on it). Adding parentheses will create groups in the regex string: `r'(\d\d\d)-(\d\d\d-\d\d\d\d)'`. Then, you can use the `group()` method of Match objects to grab the matching text from just one group.  

The first set of parentheses in a regex string will be group 1. The second set will be group 2. By passing the integer 1 or 2 to the `group(`) method, you can grab different parts of the matched text. Passing 0 or nothing to the `group()` method will return the entire matched text. For example:
```python
import re

phone_re = re .compile(r'(\d\d\d) -(\d\d\d -\d\d\d\d)')
mo = phone_re.search('My number is 415-555-4242.')

mo.group(1)  # '415'
mo.group(2)  # '555-4242'
mo.group(0)  # '415-555-4242'
mo.group()  # '415-555-4242'
```
If you would like to retrieve all the groups at once, use the `groups()` method (note the plural form in the name):
```python
mo.groups() # ('415', '555-4242')

area_code, main_number = mo.groups()

print(area_code) # 415
print(main_number) # 555-4242
```
Because `mo.groups()` returns a tuple of multiple values, you can use the multiple-assignment trick to assign each value to a separate variable.

### Using Escape Characters:
Parentheses create groups in regular expressions and are not interpreted as part of the text pattern. To match a parenthesis in your text, for instance, maybe the phone numbers you are trying to match have the area code set in parentheses: '(415) 555-4242'.  In this case, you need to escape the ( and ) characters with a backslash. The `\(` and `\)` escaped parentheses will be interpreted as part of the pattern you are matching. For example:
```python
pattern = re .compile(r'(\(\d\d\d\)) (\d\d\d-\d\d\d\d)')

mo = pattern.search('My phone number is (415) 555-4242.')

mo.group(1) # '(415)'
mo.group(2) # '555-4242'
```
The `\(` and `\)` escape characters in the raw string passed to `re.compile()` will match actual parenthesis characters. In regular expressions, the following characters have special meanings:
```txt
 # $ & ( ) * + - . ? [ \ ] ^ { | } ~
```
If you want to detect these characters as part of your text pattern, you need to escape them with a backslash:
```txt
 \# \$ \& \( \) \* \+ \- \. \? \[ \\ \] \^ \{ \| \} \~
```
Always double-check that you haven’t mistaken escaped parentheses `\(` and `\)` for unescaped parentheses ( and ) in a regular expression. If you receive an error message about “missing )” or “unbalanced parenthesis,” you may have forgotten to include the closing unescaped parenthesis for a group, like in this example:
```python
import re
re .compile(r'(\(Parentheses\)')
Traceback (most recent call last):
--snip-
re.error: missing ), unterminated subpattern at position 0
```
The error message tells you that there is an opening parenthesis at index `0` of the `r'(\(Parentheses\)'` string that is missing its corresponding closing parenthesis. We can use the `Humre` module to prevent these kinds of typos.

###  Matching Characters from Alternate Groups:
The `|` character is called a *pipe*, and it’s used as the *alternation operator* in regular expressions. You can use it anywhere you want to match one of multiple expressions. For example, the regular expression `r'Cat|Dog'` will match either `'Cat'` or `'Dog'`.  

You can also use the pipe to match one of several patterns as part of your regex. For example, say you wanted to match any of the strings `'Caterpillar'`, `'Catastrophe'`, `'Catch'`, or `'Category'`. Since all of these strings start with `Cat`, it would be nice if you could specify that prefix only once. You can do this by using the pipe within parentheses to separate the possible suffixes. For example:
```python
import re

pattern = re .compile(r'Cat(erpillar|astrophe|ch|egory)')
match = pattern.search('Catch me if you can.')

match.group() # 'Catch'
match.group(1) # 'ch
```
The method call `match.group()` returns the full matched text `'Catch'`, while `match.group(1)` returns just the part of the matched text inside the first parentheses group, `'ch'`. By using the pipe character and grouping parentheses, you can specify several alternative patterns you would like your regex to match.  
If you need to match an actual pipe character, escape it with a backslash, like `\|`.

### Returning All Matches:
In addition to a `search()` method, Pattern objects have a `findall()` method. While `search()` will return a Match object of the *first* matched text in the searched string, the `findall()` method will return the strings of *every* match in the searched string.

There is one detail you need to keep in mind when using `findall()`. The method returns a list of strings as long as there are no groups in the regular expression. For example:
```python
import re

pattern = re .compile(r'\d{3} -\d{3} -\d{4}')  # This regex has no groups.
pattern.findall('Cell: 415-555-9999 Work: 212-555-0000')

# ['415-555-9999', '212-555-0000']
```
If there are groups in the regular expression, then `findall()` will return a list of tuples. Each tuple represents a single match, and the tuple has strings for each group in the regex. Let's see this behavior in action:
```python
import re

pattern = re .compile(r'(\d{3}) -(\d{3}) -(\d{4})')  # This regex has groups.
pattern.findall('Cell: 415-555-9999 Work: 212-555-0000')

# [('415', '555', '9999'), ('212', '555', '0000')]
```
Also keep in mind that `findall()` doesn’t overlap matches. For example, matching three numbers with the regex string `r'\d{3}'` matches the first three numbers in `'1234'` but not the last three:
```python
import re

pattern = re .compile(r'\d{3}')

pattern.findall('1234') # ['123']
pattern.findall('12345') # ['123']
pattern.findall('123456') # ['123', '456']
```
Because the first three digits in `'1234'` have been matched as `'123'`, the digits `'234'` won’t be included in further matches, even though they fit the `r'\d{3}'` pattern.

## Qualifier Syntax: What Characters to Match
Regular expressions are split into two parts: the *qualifiers* that dictate what characters you are trying to match followed by the *quantifiers* that dictate how many characters you are trying to match. In the `r'\d{3}-\d{3}-\d{4}'` phone number regex string example we’ve been using, the `r'\d'` and `'-'` parts are qualifiers and the `'{3}'` and `'{4}'` are quantifiers. Let’s now examine the syntax of qualifiers.

### Using Character Classes and Negative Character Classes:
Although you can define a single character to match, as we’ve done in the previous examples, you can also define a set of characters to match inside square brackets. This set is called a *character class*. For example, the character class `[aeiouAEIOU]` will match any vowel, both lowercase and uppercase. It’s the equivalent of writing `a|e|i|o|u|A|E|I|O|U`, but it’s easier to type. For example:
```python
import re

vowel_pattern = re .compile(r'[aeiouAEIOU]')
vowel_pattern.findall('RoboCop eats BABY FOOD.')

# ['o', 'o', 'o', 'e', 'a', 'A', 'O', 'O']
```
You can also include ranges of letters or numbers by using a hyphen. For example, the character class `[a-zA-Z0-9]` will match all lowercase letters, uppercase letters, and numbers.  

Note that, inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape characters such as parentheses inside the square brackets if you want to match literal parentheses. For example, the character class `[()]` will match either an open or close parenthesis. You do not need to write this as `[\(\)]`.  

By placing a caret character (^) just after the character class’s opening bracket, you can make a *negative character class*. A negative character class will match all the characters that are not in the character class. For example:
```python
import re

consonant_pattern = re .compile(r'[^aeiouAEIOU]')
consonant_pattern.findall('RoboCop eats BABY FOOD.')

# ['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']
```
Now, instead of matching every vowel, we’re matching every character that isn’t a vowel. Keep in mind that this includes spaces, newlines, punctuation characters, and numbers.

### Using Shorthand Character Classes:
In the earlier phone number regex example, we learned that `\d` could stand for any numeric digit. That is, `\d` is shorthand for the regular  expression `0|1|2|3|4|5|6|7|8|9` or `[0-9]`. There are many such shorthand character classes, as shown below:
#### Shorthand Codes for Common Character Classes:
| Shorthand character class | Represents... |
|:--------------------------|:--------------|
| \d | Any numeric digit from 0 to 9 |
| \D | Any character that is not a numeric digit from 0 to 9 |
| \w | Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters .) |
| \W | Any character that is not a letter, numeric digit, or the underscore character |
| \s | Any space, tab, or newline character . (Think of this as matching “space” characters .) |
| \S | Any character that is not a space, tab, or newline character |

#### Note:
While `\d` matches digits and `\w` matches digits, letters, and the underscore, there is no shorthand character class that matches only letters. Though you can use the `[a-zA-Z]` character class, this character class won’t match accented letters or non-Roman alphabet letters such as `'é'`. Also, remember to use raw strings to escape the backslash: `r'\d'`. For example:
```python
import re

pattern = re .compile(r'\d+\s\w+')
pattern.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge')

# ['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', ' 6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']
```
The regular expression `\d+\s\w+` will match text that has one or more numeric digits `(\d+)`, followed by a whitespace character `(\s)`, followed by one or more letter/digit/underscore characters `(\w+)`. The `findall()` method returns all matching strings of the regular expression pattern in a list.

### Matching Everything with the Dot Character:
The `.` (or *dot*) character in a regular expression string matches any character except for a newline. For example:
```python
import re

at_re = re .compile(r' .at')
at_re.findall('The cat in the hat sat on the flat mat.')

# ['cat', 'hat', 'sat', 'lat', 'mat']
```
Remember that the dot character will match just one character, which is why the text `flat` in the previous example matched only `lat`. To match an actual period, escape the dot with a backslash: `\.`

### Being Careful What You Match For:
The best and worst thing about regular expressions is that they will match exactly what you ask for. Here are some common points of confusion regarding character classes:
 - The `[A-Z]` or `[a-z]` character class matches uppercase or lowercase letters, respectively, but not both. You need to use `[A-Za-z]` to match both cases.
 - The `[A-Za-z]` character class matches only plain, unaccented letters. For example, the regex string `r'First Name: ([A-Za-z]+)`' would match “First Name: ” followed by a group of one or more unaccented letters. But singer Sinéad O’Connor’s first name would match up to the *é* only, and the group would be set to `'Sin'`.
 - The `\w` character class matches all letters, including accented letters and characters from other alphabets. But it also matches numbers and the underscore character, so the regex string `r'First Name: (\w+)'` may match more than you intended.
 - The `\w` character class matches all letters, but the regex string `r'Last Name: (\w+)'` would capture Sinéad O’Connor’s last name only up until the apostrophe character. This means the group would capture her last name as `'O'`.
 - Straight and smart quote characters (' " ‘ ’ “ ”) are considered completely different from each other and must be specified separately.

Real-world data is complicated. Even if your program manages to capture Sinéad O’Connor’s name, it could fail with Jean-Paul Sartre’s name because of the hyphen. Of course, when software declares a name to be invalid input, it is the software, and not the name, that has a bug; people’s names cannot be invalid.
