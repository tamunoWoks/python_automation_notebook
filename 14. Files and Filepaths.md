Variables are a fine way to store data while your program is running, but if you want your data to persist even after your program has finished, you need to save it to a file. You can think of a file’s contents as a single string value, potentially gigabytes in size.

## Files and Filepaths
A file has two key properties: a *filename* (usually written as one word) and a *path*. The path specifies the location of a file on the computer. For example, there is a file on my Windows laptop with the filename *project.docx* in the path 
*C:\Users\Tammy\Documents*. The part of the filename after the last period is called the file’s extension and tells you a file’s type. The filename *project.docx* is a Word document, and *Users*, *Tammy*, and *Documents* all refer to *folders* (also called *directories*). Folders can contain files and other folders (called *subfolders*). For example, *project.docx* is in the *Documents* folder, which is inside the *Tammy* folder, which is inside the *Users* folder.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The C:\ part of the path is the *root folder*, which contains all the other folders. On Windows, the root folder is named C:\ and is also called the *C:drive*. On macOS and Linux, the root folder is `/`. For this note we’ll use the Windows-style root folder, C:\ .  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Additional *volumes*, such as a DVD drive or USB flash drive, will appear 
differently on different operating systems. On Windows, they appear as new, lettered root drives, such as D:\ or E:\ . On macOS, they appear as new folders under the */Volumes* folder. On Linux, they appear as new folders under the */mnt* (“mount”) folder. Also note that while folder names and filenames are not case-sensitive on Windows and macOS, they are case sensitive on Linux.

### Standardizing Path Separators
On Windows, paths are written using backslashes `\` as the separator between folder names. The macOS and Linux operating systems, however, use the forward slash `/` as their path separator.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `Path()` function in the `pathlib` module handles all operating systems, so the best practice is to use forward slashes in your Python code. If you pass it the string values of individual file and folder names in your path, `Path()` will return a string with a filepath using the correct path separators. For example:
```python
from pathlib import Path

Path('spam', 'bacon', 'eggs')
# WindowsPath('spam/bacon/eggs')

str(Path('spam', 'bacon', 'eggs'))
# 'spam\\bacon\\eggs'
```
While the `WindowsPath` object may use `/` forward slashes, converting it to a string with the `str()` function requires using `\` backslashes. Note that the convention for importing `pathlib` is to run `from pathlib import Path`, since otherwise we’d have to enter `pathlib.Path` everywhere `Path` shows up in our code.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I’m running these examples on Windows, so `Path('spam', 'bacon', 'eggs')` returned a `WindowsPath` object for the joined path, represented as `WindowsPath('spam/bacon/eggs')`. Even though Windows uses backslashes, the `WindowsPath` representation in the example displays them using forward slashes, as open source software developers have historically favored the Linux operating system.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want to get a simple text string of this path, you can pass it to the `str()` function, which in our example returns `'spam\\bacon\\eggs'`. (Notice that we double the backslashes because we need to escape each backslash with another backslash character.) If I had called this function on macOS or Linux, `Path()` would have returned a `PosixPath` object that, when passed to `str()`, would have returned `'spam/bacon/eggs'`. (*POSIX* is a set of standards for Unix-like operating systems.)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you work with `Path` objects, `WindowsPath` and `PosixPath` never have to appear in your source code directly. These `Path` objects will be passed to several of the file-related functions introduced in this chapter. For example, the following code joins names from a list of filenames to the end of a folder’s name:
```python
from pathlib import Path

my_files = ['accounts.txt', 'details.csv', 'invite.docx']
for filename in my_files:
    print(Path(r'C:\Users\Tammy', filename))

# C:\Users\Tammy\accounts.txt
# C:\Users\Tammy\details.csv
# C:\Users\Tammy\invite.docx
```
On Windows, the backslash separates directories, so you can’t use it in f ilenames. However, you can use backslashes in filenames on macOS and Linux. So, while `Path(r'spam\eggs')` refers to two separate folders (or a file `eggs` in a folder `spam`) on Windows, the same command would refer to a single folder (or file) named `spam\eggs` on macOS and Linux. For this reason, it’s usually a good idea to always use forward slashes in your Python code. The `pathlib` module will ensure that your code always works on all operating systems.

###  Joining Paths
We normally use the `+` operator to add two integer or floating-point numbers, such as in the expression `2 + 2`, which evaluates to the integer value `4`. But we can also use the `+` operator to concatenate two string values, like the expression `'Hello' + 'World'`, which evaluates to the string value `'HelloWorld'`. Similarly, the `/` operator that we normally use for division can combine `Path` objects and strings. This is helpful for modifying a `Path` object after you’ve 
already created it with the `Path()` function. For example:
```python
from pathlib import Path

Path('spam') / 'bacon' / 'eggs'
# WindowsPath('spam/bacon/eggs')

Path('spam') / Path('bacon/eggs')
# WindowsPath('spam/bacon/eggs')

Path('spam') / Path('bacon', 'eggs')
# WindowsPath('spam/bacon/eggs')
```
The only thing you need to keep in mind when using the `/` operator for joining paths is that one of the first two values in the expression must be a `Path` object. This is because these expressions evaluate from left to right, and the `/` operator can be used on two `Path` objects or on a `Path` object and a string, but not on two strings. Python will give you an error if you try to enter the following:
```python
'spam' / 'bacon'

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for /: 'str' and 'str'
```
So, either the first or second leftmost value must be a `Path` object for the entire expression to evaluate to a `Path` object.  If you see the `TypeError: unsupported operand type(s) for /: 'str' and 'str'` error message shown previously, you need to put a `Path` object instead of a string on the left side of the expression.  
The `/` operator replaces the older `os.path.join()` function.

### Accessing the Current Working Directory
Every program that runs on your computer has a current working directory. Any filenames or paths that do not begin with the root folder are assumed to be under the current working directory.  

**NOTE:**  
While *folder* is the more modern name for *directory*, note that *current working directory* (or just *working directory*) is the standard term, not current working folder.  

You can get the current working directory as a string value with the `Path.cwd()` function and can change it using `os.chdir()`. For example:
```python
from pathlib import Path
import os

Path.cwd()
# WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python313')'

os.chdir('C:\\Windows\\System32')

Path.cwd()
# WindowsPath('C:/Windows/System32')
```
Here, the current working directory is set to `C:\Users\Al\AppData\Local\ Programs\Python\Python313`, so the filename `project.docx` refers to `C:\Users\Al\ AppData\Local\Programs\Python\Python313\project.docx`. When we change the current working directory to `C:\Windows\System32`, the filename `project.docx` is interpreted as `C:\Windows\System32\project.docx`.  

Python will display an error if you try to change to a directory that does not exist:
```python
import os

os.chdir('C:/ThisFolderDoesNotExist')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [WinError 2] The system cannot find the file specified: 'C:/ThisFolderDoesNotExist'
```
There is no `pathlib` function for changing the working directory. You must use `os.chdir()`. The `os.getcwd()` function is the older way of getting the current working directory as a string.

### Accessing the Home Directory
All users have a folder for their own files on their computer; this folder is called the `home directory` or `home folder`. You can get a Path object of the home folder by calling `Path.home()`:
```python
from pathlib import Path

Path.home()
# WindowsPath('C:/Users/Al')
```
The home directories are located in a set place depending on your operating system:
- On Windows, home directories are under *C:\Users*.
- On macOS, home directories are under */Users*.
- On Linux, home directories are often under */home*.

Your scripts will almost certainly have permissions to read and write the files under your home directory, so it’s an ideal place to put the files that your Python programs will work with.
