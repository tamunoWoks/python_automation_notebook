## Qualifier Syntax: What Characters to Match
Regular expressions are split into two parts: the *qualifiers* that dictate what characters you are trying to match followed by the *quantifiers* that dictate how many characters you are trying to match. In the `r'\d{3}-\d{3}-\d{4}'` phone number regex string example we’ve been using, the `r'\d'` and `'-'` parts are qualifiers and the `'{3}'` and `'{4}'` are quantifiers. Let’s now examine the syntax of qualifiers.

### Using Character Classes and Negative Character Classes:
Although you can define a single character to match, as we’ve done in the previous examples, you can also define a set of characters to match inside square brackets. This set is called a *character class*. For example, the character class `[aeiouAEIOU]` will match any vowel, both lowercase and uppercase. It’s the equivalent of writing `a|e|i|o|u|A|E|I|O|U`, but it’s easier to type. For example:
```python
import re

vowel_pattern = re .compile(r'[aeiouAEIOU]')
vowel_pattern.findall('RoboCop eats BABY FOOD.')

# ['o', 'o', 'o', 'e', 'a', 'A', 'O', 'O']
```
You can also include ranges of letters or numbers by using a hyphen. For example, the character class `[a-zA-Z0-9]` will match all lowercase letters, uppercase letters, and numbers.  

Note that, inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape characters such as parentheses inside the square brackets if you want to match literal parentheses. For example, the character class `[()]` will match either an open or close parenthesis. You do not need to write this as `[\(\)]`.  

By placing a caret character (^) just after the character class’s opening bracket, you can make a *negative character class*. A negative character class will match all the characters that are not in the character class. For example:
```python
import re

consonant_pattern = re .compile(r'[^aeiouAEIOU]')
consonant_pattern.findall('RoboCop eats BABY FOOD.')

# ['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']
```
Now, instead of matching every vowel, we’re matching every character that isn’t a vowel. Keep in mind that this includes spaces, newlines, punctuation characters, and numbers.

### Using Shorthand Character Classes:
In the earlier phone number regex example, we learned that `\d` could stand for any numeric digit. That is, `\d` is shorthand for the regular  expression `0|1|2|3|4|5|6|7|8|9` or `[0-9]`. There are many such shorthand character classes, as shown below:
#### Shorthand Codes for Common Character Classes:
| Shorthand character class | Represents... |
|:--------------------------|:--------------|
| \d | Any numeric digit from 0 to 9 |
| \D | Any character that is not a numeric digit from 0 to 9 |
| \w | Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters .) |
| \W | Any character that is not a letter, numeric digit, or the underscore character |
| \s | Any space, tab, or newline character . (Think of this as matching “space” characters .) |
| \S | Any character that is not a space, tab, or newline character |

#### Note:
While `\d` matches digits and `\w` matches digits, letters, and the underscore, there is no shorthand character class that matches only letters. Though you can use the `[a-zA-Z]` character class, this character class won’t match accented letters or non-Roman alphabet letters such as `'é'`. Also, remember to use raw strings to escape the backslash: `r'\d'`. For example:
```python
import re

pattern = re .compile(r'\d+\s\w+')
pattern.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge')

# ['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', ' 6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']
```
The regular expression `\d+\s\w+` will match text that has one or more numeric digits `(\d+)`, followed by a whitespace character `(\s)`, followed by one or more letter/digit/underscore characters `(\w+)`. The `findall()` method returns all matching strings of the regular expression pattern in a list.

### Matching Everything with the Dot Character:
The `.` (or *dot*) character in a regular expression string matches any character except for a newline. For example:
```python
import re

at_re = re .compile(r' .at')
at_re.findall('The cat in the hat sat on the flat mat.')

# ['cat', 'hat', 'sat', 'lat', 'mat']
```
Remember that the dot character will match just one character, which is why the text `flat` in the previous example matched only `lat`. To match an actual period, escape the dot with a backslash: `\.`

### Being Careful What You Match For:
The best and worst thing about regular expressions is that they will match exactly what you ask for. Here are some common points of confusion regarding character classes:
 - The `[A-Z]` or `[a-z]` character class matches uppercase or lowercase letters, respectively, but not both. You need to use `[A-Za-z]` to match both cases.
 - The `[A-Za-z]` character class matches only plain, unaccented letters. For example, the regex string `r'First Name: ([A-Za-z]+)`' would match “First Name: ” followed by a group of one or more unaccented letters. But singer Sinéad O’Connor’s first name would match up to the *é* only, and the group would be set to `'Sin'`.
 - The `\w` character class matches all letters, including accented letters and characters from other alphabets. But it also matches numbers and the underscore character, so the regex string `r'First Name: (\w+)'` may match more than you intended.
 - The `\w` character class matches all letters, but the regex string `r'Last Name: (\w+)'` would capture Sinéad O’Connor’s last name only up until the apostrophe character. This means the group would capture her last name as `'O'`.
 - Straight and smart quote characters (' " ‘ ’ “ ”) are considered completely different from each other and must be specified separately.
