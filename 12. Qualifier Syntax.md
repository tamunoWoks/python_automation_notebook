## Qualifier Syntax: What Characters to Match
Regular expressions are split into two parts: the *qualifiers* that dictate what characters you are trying to match followed by the *quantifiers* that dictate how many characters you are trying to match. In the `r'\d{3}-\d{3}-\d{4}'` phone number regex string example we’ve been using, the `r'\d'` and `'-'` parts are qualifiers and the `'{3}'` and `'{4}'` are quantifiers. Let’s now examine the syntax of qualifiers.

### Using Character Classes and Negative Character Classes:
Although you can define a single character to match, as we’ve done in the previous examples, you can also define a set of characters to match inside square brackets. This set is called a *character class*. For example, the character class `[aeiouAEIOU]` will match any vowel, both lowercase and uppercase. It’s the equivalent of writing `a|e|i|o|u|A|E|I|O|U`, but it’s easier to type. For example:
```python
import re

vowel_pattern = re .compile(r'[aeiouAEIOU]')
vowel_pattern.findall('RoboCop eats BABY FOOD.')

# ['o', 'o', 'o', 'e', 'a', 'A', 'O', 'O']
```
You can also include ranges of letters or numbers by using a hyphen. For example, the character class `[a-zA-Z0-9]` will match all lowercase letters, uppercase letters, and numbers.  

Note that, inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape characters such as parentheses inside the square brackets if you want to match literal parentheses. For example, the character class `[()]` will match either an open or close parenthesis. You do not need to write this as `[\(\)]`.  

By placing a caret character (^) just after the character class’s opening bracket, you can make a *negative character class*. A negative character class will match all the characters that are not in the character class. For example:
```python
import re

consonant_pattern = re .compile(r'[^aeiouAEIOU]')
consonant_pattern.findall('RoboCop eats BABY FOOD.')

# ['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']
```
Now, instead of matching every vowel, we’re matching every character that isn’t a vowel. Keep in mind that this includes spaces, newlines, punctuation characters, and numbers.

### Using Shorthand Character Classes:
In the earlier phone number regex example, we learned that `\d` could stand for any numeric digit. That is, `\d` is shorthand for the regular  expression `0|1|2|3|4|5|6|7|8|9` or `[0-9]`. There are many such shorthand character classes, as shown below:
#### Shorthand Codes for Common Character Classes:

| Shorthand character class | Represents... |
|:--------------------------|:--------------|
| \d | Any numeric digit from 0 to 9 |
| \D | Any character that is not a numeric digit from 0 to 9 |
| \w | Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters .) |
| \W | Any character that is not a letter, numeric digit, or the underscore character |
| \s | Any space, tab, or newline character . (Think of this as matching “space” characters .) |
| \S | Any character that is not a space, tab, or newline character |
