### Virtual Environments
 Say you have two Python programs, one that uses version 1.0 of a package and another that uses version 2.0 of that same package. Python can’t have two versions of the same package installed at the same time. If version 2.0 is not backward compatible with version 1.0, you’d be uninstalling one version and reinstalling the other each time you wanted to switch programs to run.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python’s solution to this problem is **virtual environments**; separate installations of Python that have their own set of installed third-party packages. In general, each Python application you create needs its own virtual environment. But you can use one virtual environment for all your small scripts while learning to program. Python can create virtual environments with its built-in `venv` module. To create a virtual environment, **cd** to your *Scripts* folder and run **python –m venv .venv** (using python3 on macOS and Linux):
```bash
C:\Users\al>
C:\Users\al>cd Scripts
C:\Users\al\Scripts>python -m venv .venv
```
This creates the virtual environment’s files in a new folder named *.venv*. You can choose any folder name you want, but *.venv* is conventional. Files and folders whose names begin with a period are hidden, though there are steps you can follow to make your operating system show them by default.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When you run `python` or `python3` from the terminal, you’ll still run your original Python installation’s interpreter. To use the virtual environment’s Python version, you must activate it. Do so by running the *C:\Users\al\Scripts\.venv\Scripts\activate.bat* script on Windows:
```bash
C:\Users\al\Scripts>cd .venv\Scripts
C:\Users\al\Scripts\.venv\Scripts>activate.bat
(.venv) C:\Users\al\Scripts\.venv\Scripts>where python.exe
C:\Users\Al\Scripts\.venv\Scripts\python.exe
C:\Users\Al\AppData\Local\Programs\Python\Python313\python.exe
C:\Users\Al\AppData\Local\Programs\Python\Python312\python.exe
```
Running `where python.exe` after activating the virtual environment shows that running python from the terminal will run the Python interpreter in the *.venv\Scripts* folder and not the system Python.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The equivalent script on macOS and Linux is *~/Scripts/.venv/bin/activate*, 
but due to security permissions, you can’t directly run it. Instead, run the command source activate:
```bash
al@al-virtual-machine:~/Scripts$ cd .venv/bin
al@al-virtual-machine:~/Scripts/.venv/bin$ source activate
(.venv) al@al-virtual-machine:~/Scripts/.venv/bin$ which python3
/home/al/Scripts/.venv/bin/python3
```
Activation changes the `PATH` environment variable so that `python` or `python3` runs the Python interpreter inside the *.venv* folder instead of the original one. It also changes your terminal prompt to include (.venv) so that you know the virtual environment is active. Running which `python3` in the activated virtual environment shows that `python3` runs the Python interpreter in the newly created *.venv/bin* folder. These changes apply to the current terminal window only; any existing or new terminal windows won’t have these environment variable or prompt changes. This fresh Python installation has only the default packages, and none of the packages you may have already installed in the original Python installation. You can confirm this by running **python –m pip list** to list the installed packages:
```bash
(.venv) C:\Users\al\Scripts\.venv\Scripts>python -m pip list
Package    Version
---------- ------
pip        23.0
setuptools 65.5.0
```
The standard practice is to create a virtual environment for each Python project you’re working on, since every project could have its own unique package dependencies. However, on Windows, we can be a bit more lax with the random small scripts we write in our *Scripts* folder: they can all share this one.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The macOS and Linux operating systems have their own programs that rely on the Python installation that comes with the operating system. Installing or updating packages for this original Python installation, called the *system Python*, has the slight chance of introducing incompatibilities that can cause these programs to fail. Running your own scripts with the system Python is fine; installing third-party packages to the system Python is slightly risky, but creating a virtual environment in your *Scripts* folder is a good precaution against installing incompatible packages.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To deactivate the virtual environment, run `deactivate.bat` (on Windows) or `source deactivate` (on macOS and Linux) in the same folder as the *activate* script. You can also simply close the terminal window and open a new one. If you want to permanently delete the virtual environment along with its installed packages, just delete the *.venv* folder and its contents.

### Installing Python Packages with Pip
Python comes with a command line package manager program called *pip* (written in lowercase unless it’s at the start of a sentence). Pip is a recursive acronym for *pip installs package*. While Python’s standard library comes with modules such as `sys`, `random`, and `os`, there are also hundreds of thousands of third-party packages you can find on *PyPI* (pronounced *pie-pee-eye* and not *pie-pie*), the Python Package Index, at *https://pypi.org*. In Python, a *package* is a collection of Python code made available on PyPI, and a *module* is an individual *.py* file containing Python code. You install packages from PyPI that contain modules, and you import modules with an *import* statement.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While pip is a program on its own, it’s easier to run it through the Python interpreter by running `python –m pip` on Windows or `python3 –m pip` on macOS and Linux, rather than running the `pip` (on Windows) or `pip3` (on macOS and Linux) program directly. This prevents errors in the rare cases where you have multiple Python installations, your `PATH` is misconfigured, and `pip/pip3` is installing to a different Python interpreter than the one that runs when you enter `python/python3`.

**NOTE: DON’T USE PIP WITH ANACONDA**  
If you’ve installed the Anaconda distribution of Python instead of the regular distribution from *https://python.org*, you should avoid using pip in your conda environments. Instead, use the conda-specific package manager through the `conda` command.  

To install a package from PyPI, enter the following into the terminal:
```bash
C:\Users\al>python –m pip install package_name
```
Remember to run `python3` if on macOS or Linux instead of `python` for these various commands. Also note that you’ll need to run this from the terminal window, and not from the Python interactive shell.  

To list all the packages you have installed along with their version numbers, run python **–m pip list**:
```bash
C:\Users\al>python -m pip list
Package                   Version     Editable project location
------------------------- ----------- ------------------------
altgraph                  0.17.3
argon2-cffi               21.3.0
argon2-cffi-bindings      21.2.0
async-generator           1.10
--snip-
wsproto                   1.2.0
```
You can also upgrade a package to the latest version on PyPI by running python `–m pip install –U package_name`, or install a particular version (say, 1.17.4) by running python `–m pip install package_name==1.17.4`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To uninstall a package, run python `–m pip uninstall package_name`. You can 
find more information about pip by running `python –m pip --help`.

### Self-Aware Python Programs
Python’s standard library doesn’t come with any modules that give your programs sentience yet. But several built-in variables can give your Python program useful information about itself, the operating system it’s on, and the Python interpreter running it. The Python interpreter sets these variables automatically.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `__file__` variable contains the *.py* file’s path as a string. For example, if I run a *yourScript.py* file in my home folder, it evaluates to *'C:\Users\al\ yourScript.py'*. Importing `from pathlib import Path` and calling `Path(__file__)` returns a `Path` object of this file. This information is useful if you need to 
locate files that exist in the Python program’s folder. The `__file__` variable doesn’t exist when you run the Python interactive shell.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `sys.executable` variable contains the full path and file of the Python interpreter program itself, and the `sys.version` variable contains the string that appears at the top of the interactive shell with version information about the Python interpreter.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `sys.version_info.major` and `sys.version_info.minor` variables contain integers of the major and minor version numbers of the Python interpreter. On my laptop running Python version 3.12.0 alpha 5, these are 3 and 12, respectively. You can also pass `sys.version_info` to the `list()` function to obtain more specific information: `list(sys.version_info)` returns `[3, 12, 0, 'final', 0]` on my laptop. Having the version information in this form is much easier to work with than trying to pull it out of the `sys.version` string.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `os.name` variable contains the string `'nt'` if running on Windows and `'posix'` if running on macOS or Linux. This is useful if your Python script needs to run different code depending on what operating system it’s running on.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For more specific operating system identification, the `sys.platform` variable contains `'win32'` on Windows, `'darwin'` on macOS, and `'linux'` on Linux.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you need highly specific information about the OS version and type of CPU, the built-in `platform` module can retrieve this information. This module is documented online at *https://docs.python.org/3/library/platform.html*.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you need to check whether a module is installed, put the `import` statement in a try block and catch the `ModuleNotFoundError` exception:
```python
try:
   import nonexistentModule
except ModuleNotFoundError:
   print('This code runs if nonexistentModule was not found.')
```
If the module is necessary for your program to function, you can put a descriptive error message here and call `sys.exit()` to terminate the program. This will be more helpful to the user than a generic error message and traceback.
