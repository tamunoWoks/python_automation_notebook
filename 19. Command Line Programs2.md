### Virtual Environments
 Say you have two Python programs, one that uses version 1.0 of a package and another that uses version 2.0 of that same package. Python can’t have two versions of the same package installed at the same time. If version 2.0 is not backward compatible with version 1.0, you’d be uninstalling one version and reinstalling the other each time you wanted to switch programs to run.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python’s solution to this problem is **virtual environments**; separate installations of Python that have their own set of installed third-party packages. In general, each Python application you create needs its own virtual environment. But you can use one virtual environment for all your small scripts while learning to program. Python can create virtual environments with its built-in `venv` module. To create a virtual environment, **cd** to your *Scripts* folder and run **python –m venv .venv** (using python3 on macOS and Linux):
```bash
C:\Users\al>
C:\Users\al>cd Scripts
C:\Users\al\Scripts>python -m venv .venv
```
This creates the virtual environment’s files in a new folder named *.venv*. You can choose any folder name you want, but *.venv* is conventional. Files and folders whose names begin with a period are hidden, though there are steps you can follow to make your operating system show them by default.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When you run `python` or `python3` from the terminal, you’ll still run your original Python installation’s interpreter. To use the virtual environment’s Python version, you must activate it. Do so by running the *C:\Users\al\Scripts\.venv\Scripts\activate.bat* script on Windows:
```bash
C:\Users\al\Scripts>cd .venv\Scripts
C:\Users\al\Scripts\.venv\Scripts>activate.bat
(.venv) C:\Users\al\Scripts\.venv\Scripts>where python.exe
C:\Users\Al\Scripts\.venv\Scripts\python.exe
C:\Users\Al\AppData\Local\Programs\Python\Python313\python.exe
C:\Users\Al\AppData\Local\Programs\Python\Python312\python.exe
```
Running `where python.exe` after activating the virtual environment shows that running python from the terminal will run the Python interpreter in the *.venv\Scripts* folder and not the system Python.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The equivalent script on macOS and Linux is *~/Scripts/.venv/bin/activate*, 
but due to security permissions, you can’t directly run it. Instead, run the command source activate:
```bash
al@al-virtual-machine:~/Scripts$ cd .venv/bin
al@al-virtual-machine:~/Scripts/.venv/bin$ source activate
(.venv) al@al-virtual-machine:~/Scripts/.venv/bin$ which python3
/home/al/Scripts/.venv/bin/python3
```
Activation changes the `PATH` environment variable so that `python` or `python3` runs the Python interpreter inside the *.venv* folder instead of the original one. It also changes your terminal prompt to include (.venv) so that you know the virtual environment is active. Running which `python3` in the activated virtual environment shows that `python3` runs the Python interpreter in the newly created *.venv/bin* folder. These changes apply to the current terminal window only; any existing or new terminal windows won’t have these environment variable or prompt changes. This fresh Python installation has only the default packages, and none of the packages you may have already installed in the original Python installation. You can confirm this by running **python –m pip list** to list the installed packages:
```bash
(.venv) C:\Users\al\Scripts\.venv\Scripts>python -m pip list
Package    Version
---------- ------
pip        23.0
setuptools 65.5.0
```
The standard practice is to create a virtual environment for each Python project you’re working on, since every project could have its own unique package dependencies. However, on Windows, we can be a bit more lax with the random small scripts we write in our *Scripts* folder: they can all share this one.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The macOS and Linux operating systems have their own programs that rely on the Python installation that comes with the operating system. Installing or updating packages for this original Python installation, called the *system Python*, has the slight chance of introducing incompatibilities that can cause these programs to fail. Running your own scripts with the system Python is fine; installing third-party packages to the system Python is slightly risky, but creating a virtual environment in your *Scripts* folder is a good precaution against installing incompatible packages.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To deactivate the virtual environment, run `deactivate.bat` (on Windows) or `source deactivate` (on macOS and Linux) in the same folder as the *activate* script. You can also simply close the terminal window and open a new one. If you want to permanently delete the virtual environment along with its installed packages, just delete the *.venv* folder and its contents.

### Installing Python Packages with Pip
Python comes with a command line package manager program called *pip* (written in lowercase unless it’s at the start of a sentence). Pip is a recursive acronym for *pip installs package*. While Python’s standard library comes with modules such as `sys`, `random`, and `os`, there are also hundreds of thousands of third-party packages you can find on *PyPI* (pronounced *pie-pee-eye* and not *pie-pie*), the Python Package Index, at *https://pypi.org*. In Python, a *package* is a collection of Python code made available on PyPI, and a *module* is an individual *.py* file containing Python code. You install packages from PyPI that contain modules, and you import modules with an *import* statement.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While pip is a program on its own, it’s easier to run it through the Python interpreter by running `python –m pip` on Windows or `python3 –m pip` on macOS and Linux, rather than running the `pip` (on Windows) or `pip3` (on macOS and Linux) program directly. This prevents errors in the rare cases where you have multiple Python installations, your `PATH` is misconfigured, and `pip/pip3` is installing to a different Python interpreter than the one that runs when you enter `python/python3`.

**NOTE: DON’T USE PIP WITH ANACONDA**  
If you’ve installed the Anaconda distribution of Python instead of the regular distribution from *https://python.org*, you should avoid using pip in your conda environments. Instead, use the conda-specific package manager through the `conda` command.  

To install a package from PyPI, enter the following into the terminal:
```bash
C:\Users\al>python –m pip install package_name
```
Remember to run `python3` if on macOS or Linux instead of `python` for these various commands. Also note that you’ll need to run this from the terminal window, and not from the Python interactive shell.  

To list all the packages you have installed along with their version numbers, run python **–m pip list**:
```bash
C:\Users\al>python -m pip list
Package                   Version     Editable project location
------------------------- ----------- ------------------------
altgraph                  0.17.3
argon2-cffi               21.3.0
argon2-cffi-bindings      21.2.0
async-generator           1.10
--snip-
wsproto                   1.2.0
```
You can also upgrade a package to the latest version on PyPI by running python `–m pip install –U package_name`, or install a particular version (say, 1.17.4) by running python `–m pip install package_name==1.17.4`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To uninstall a package, run python `–m pip uninstall package_name`. You can 
find more information about pip by running `python –m pip --help`.

### Self-Aware Python Programs
Python’s standard library doesn’t come with any modules that give your programs sentience yet. But several built-in variables can give your Python program useful information about itself, the operating system it’s on, and the Python interpreter running it. The Python interpreter sets these variables automatically.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `__file__` variable contains the *.py* file’s path as a string. For example, if I run a *yourScript.py* file in my home folder, it evaluates to *'C:\Users\al\ yourScript.py'*. Importing `from pathlib import Path` and calling `Path(__file__)` returns a `Path` object of this file. This information is useful if you need to 
locate files that exist in the Python program’s folder. The `__file__` variable doesn’t exist when you run the Python interactive shell.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `sys.executable` variable contains the full path and file of the Python interpreter program itself, and the `sys.version` variable contains the string that appears at the top of the interactive shell with version information about the Python interpreter.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `sys.version_info.major` and `sys.version_info.minor` variables contain integers of the major and minor version numbers of the Python interpreter. On my laptop running Python version 3.12.0 alpha 5, these are 3 and 12, respectively. You can also pass `sys.version_info` to the `list()` function to obtain more specific information: `list(sys.version_info)` returns `[3, 12, 0, 'final', 0]` on my laptop. Having the version information in this form is much easier to work with than trying to pull it out of the `sys.version` string.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `os.name` variable contains the string `'nt'` if running on Windows and `'posix'` if running on macOS or Linux. This is useful if your Python script needs to run different code depending on what operating system it’s running on.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For more specific operating system identification, the `sys.platform` variable contains `'win32'` on Windows, `'darwin'` on macOS, and `'linux'` on Linux.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you need highly specific information about the OS version and type of CPU, the built-in `platform` module can retrieve this information. This module is documented online at *https://docs.python.org/3/library/platform.html*.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you need to check whether a module is installed, put the `import` statement in a try block and catch the `ModuleNotFoundError` exception:
```python
try:
   import nonexistentModule
except ModuleNotFoundError:
   print('This code runs if nonexistentModule was not found.')
```
If the module is necessary for your program to function, you can put a descriptive error message here and call `sys.exit()` to terminate the program. This will be more helpful to the user than a generic error message and traceback.

###  Text-Based Program Design
Before GUI-supporting operating systems were common, all programs used text to communicate with their user. We focus on creating small, useful programs rather than professional software applications, so our programs use `print()` and `input()` through a command line interface rather than the windows, buttons, and graphics that a GUI provides.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Even when limited to text, however, software applications can still provide a user interface similar to modern GUIs. These kinds of applications are retroactively called *TUI* (pronounced “two-ee”), or *text-based user interface*, applications.
#### Short Command Names:
Users often run text-based programs from the command line rather than by clicking an icon on the desktop or Start menu. We read source code more often than we write it, so using verbose names for variables and functions helps. But we type commands into the command line more often than we read them, so in this case, the opposite is true: short command names make the command line easier to use.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If your program is a command that you’ll likely type a dozen times a day, try to think of a short name for it. You can use the `which` and `where` commands to check if the name already exists for another program. You can also do an internet search for any existing commands by that name.
#### Command Line Arguments:
To run a program from the command line, simply enter its name. For *.py* Python source code files, you must run the `python` (Windows) or `python3` (macOS and Linux) program and then supply the *.py* filename after it, like this: `python yourScript.py`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The bit of text supplied after a command is called a *command line argument*. Command line arguments are passed to commands in much the same way as arguments to a function call. For example, the `ls` command by itself lists the files in the CWD. But you could also run `ls exampleFolder`, and the `exampleFolder` command line argument would direct the `ls` command to list the files in the `exampleFolder` folder. Command line arguments allow you to configure the behavior of the command.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python scripts can access the command line scripts given to the Python interpreter from the `sys.argv` list. For example, if you entered `python3 yourScript.py hello world`, the `python3` program would receive the command line arguments and forward them to your Python script in the `sys.argv` variable. The `sys.argv` variable would contain `['yourScript.py', 'hello', 'world']`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that the first item in `sys.argv` is the filename of the Python script. The remaining arguments are split by spaces. If you need to include space characters in a command line argument, put them inside double quotation marks when running the command. For example, `python3 yourScript.py "hello world"` would set `sys.argv` to `['yourScript.py', 'hello world']`.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you pass `/?` after any Windows command or `--help` after any macOS or Linux command, you’ll often find page after page of command line argument documentation.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Should python `yourScript.py spam eggs` do the same thing as `python yourScript.py eggs spam`? If the user can have either a cheese argument or a bacon argument, what happens if they provide both? This complexity would require you to write a lot of code to handle the various edge cases. At this point, you’re probably better off using Python’s built-in `argparse` module to handle these complicated situations. You can read its documentation online at *https://docs.python.org/3 /library/argparse.html*.
#### Clipboard I/O:
You don’t need to rely on `input()` to read text from files or the keyboard. You can also use the clipboard for your Python program’s text input and output. The cross-platform `pyperclip` module has a `copy()` function for placing text on the clipboard and a `paste()` function that returns the clipboard’s text as a string. Pyperclip is a third-party package installed from the terminal with pip: `python –m pip install pyperclip`. On Linux, you’ll also have to run `sudo apt-get install xclip` to make Pyperclip work.  
All of your clipboard I/O programs will follow this basic design:
 1. Import the `pyperclip` module.
 2. Call `pyperclip.paste()` to obtain the input text from the clipboard.
 3. Perform some work on the text.
 4. Copy the results to the clipboard by passing them to `pyperclip copy()`.  
#### Colorful Text with Bext:
You can print colorful text using the third-party Bext package built on top of Jonathan Hartley’s Colorama package. Install Bext with pip. Bext only works in programs run from a terminal window. To have `print()` produce colorful text, call the `fg()` and `bg()` functions to change the (foreground) text color or the background color with a string argument such as 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'purple', 'cyan', or 'white'. You can also pass `'reset'` to change the color back to the terminal window’s default color. For example:
```python
import bext

bext.fg('red')
print('This text is red.') # This text is red.

bext.bg('blue')
print('Red text on blue background is an ugly color scheme.') # Red text on blue background is an ugly color scheme.

bext.fg('reset')
bext.bg('reset')

print('The text is normal again. Ah, much better.') # The text is normal again. Ah, much better.
```
Keep in mind that the user may have their terminal window set to light mode or dark mode, so there’s no telling if the terminal’s default appearance is black text on a white background or white text on a black background. You should also be limited in your use of color: too much can make your program look tacky or unreadable.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bext also has some limited TUI-like features, including the following:
- **bext.clear()** - Clears the screen
- **bext.width() and bext.height()** - Returns the current width (in columns) and height (in rows) of the terminal window, respectively
- **bext.hide() and bext.show()** - Hides and shows the cursor, respectively
- **bext.title(text)** - Changes the title bar of the terminal window to the text string
- **bext.goto(x, y)** - Moves the cursor to column x and row y in the terminal, where 0, 0 is the top-left position
- **bext.get_key()** - Waits for the user to press any key and then returns a string describing the key.  

Think of the `bext.get_key()` function as a single-key version of `input()`. The returned string includes 'a', 'z', and '5', but also keys like 'left', 'f1', and 'esc'. The tab and enter keys return '\t' and '\n', respectively. Call `bext.get_key()` in the interactive shell to test various keys and see their return values.
#### Terminal Clearing:
The `bext.clear()` function is useful if you’d like your program to remove any text left over from before it ran. You can also use it to do flipbook-style animation: call `clear()` to clear the terminal, then use `print()` calls to fill it with 
text, pause for a moment with Python’s `time.sleep()`, and then repeat. There is a Python one-liner (a single line of code to do a special trick) to clear the screen that you can place in your own `clear()` function:
```python
import os
def clear():
   os.system('cls' if os.name == 'nt' else 'clear')
```
This code lets your program clear the terminal screen without requiring the installation of the Bext package and only works in Python scripts run from the terminal. The `os.system()` call runs the `cls` program (on Windows) or the `clear` program (on macOS and Linux). The odd syntax here is an example of Python’s *conditional expressions* (also called *ternary operators* in other languages). The syntax is `value1 if condition else value2`, which evaluates to `value1` if condition is `True` and `value2` if condition is `False`.  
In our case, the conditional expression evaluates to `'cls'` if the condition `os.name == 'nt'` is `True`; otherwise, it evaluates to `'clear'`. Conditional expressions (and one-liners in general) often produce unreadable code and are usually best avoided, but this is a simple enough case.
#### Sound and Text Notification:
Terminal programs existed before the rich audio that today’s computers provide. Today, there’s no reason your text-based programs must be silent. There are, however, good reasons to keep sounds to a minimum or to exclude them altogether. Sounds can provide notification that a task is complete or a problem has occurred when the user is busy looking at other windows. But, like colorful text, it’s easy to overuse sounds to the point of annoyance. The user may already be doing a task that involves playing audio, or perhaps they’re in an online meeting that the sound would rudely interrupt. And if the user’s 
computer is muted, they won’t hear the sound notification anyway.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you just need to play a simple audio file, you can use the playsound third-party package. Once it’s installed, you can play an audio file by calling the `playsound` module’s `playsound()` function and passing the filepath of an MP3 or WAV audio file. For example:
```python
import playsound
playsound.playsound('hello.mp3')
```
The `playsound(`) function won’t return until the audio file has finished playing; that is, the function blocks until the audio has finished. Keep in mind that this will halt your program for a while if you give it a long audio file to play. If `playsound()` raises exceptions (which happens if the filename contains odd characters such as an equal sign), try passing a `Path` object of the audio file instead of a string.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarly, you may want to limit the text produced by your program. Under the Unix philosophy of command design, piping the text output of one command to another is easier if the command outputs only relevant information, as extraneous text output would have to be filtered. Many commands keep their text output to a minimum, or they have none at all and communicate success or error with the exit code. However, if you aren’t piping the output to another command but, as a human user, want to see more information, many commands accept a `-v` or `--verbose` command line argument to enable this verbose mode. Other commands take the opposite approach and flood the output with information, but offer a `-q` or `--quiet` command line argument to offer a quiet mode of no text output instead. (This could double as a way to mute sound notifications as well.) Or better yet, make silence the default behavior and have `--verbose` or `--beep` enable sound or alert beeps.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If your program doesn’t require this level of sophistication, you can ignore this consideration. However, once you start sharing your programs with others who may use it in clever ways you didn’t foresee, offering these options goes a long way toward making your programs user-friendly.
