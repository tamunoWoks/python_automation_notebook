##  Quantifier Syntax: How Many Qualifiers to Match
In a regular expression string, quantifiers follow qualifier characters to dictate how many of them to match. For example, in the phone number regex considered earlier, the `{3}` follows the `\d` to match exactly three digits.  

If there is no quantifier following a qualifier, the qualifier must appear exactly once: you can think of `r'\d'` as being the same as `r'\d{1}'`

### Matching an Optional Pattern:
Sometimes you may want to match a pattern only optionally. That is, the regex should match zero or one of the preceding qualifiers. The `?` character flags the preceding qualifier as optional. For example:
```python
import re

pattern = re .compile(r'42! ?')

pattern.search('42!')
<re.Match object; span=(0, 3), match='42!'>

pattern.search('42')
<re.Match object; span=(0, 2), match='42'>
```
The `?` part of the regular expression means that the pattern `!` is optional. So it matches both `42!` (with the exclamation mark) and `42` (without it). The `?` question mark has meaning in regex syntax, but the `!` exclamation mark doesn’t. So `r'42!?'` means `'42'` optionally followed by a `'!'`, but `r'42?!'` means `'4'` optionally followed by `'2'` followed by `'!'`:
```python
import re

pattern = re .compile(r'42 ?!')

pattern.search('42!')
<re.Match object; span=(0, 3), match='42!'>

pattern.search('4!')
<re.Match object; span=(0, 2), match='4!'>

pattern.search('42') == None  # No match
True
```
To make multiple characters optional, place them in a group and put the `?` after the group. In the earlier phone number example, you can use `?` to make the regex look for phone numbers that either do or do not have an area code.
```python
pattern = re .compile(r'(\d{3} -) ?\d{3} -\d{4}')

match1 = pattern.search('My number is 415-555-4242')
match1.group() # '415-555-4242'

match2 = pattern.search('My number is 555-4242')
match2.group() # '555-4242'
```
You can think of the `?` as saying, “Match zero or one of the group preceding this question mark.”. If you need to match an actual question mark character, escape it with `\?`.

### Matching Zero or More Qualifiers:
The `*` (called the star or asterisk) means “match zero or more.” In other words, the qualifier that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. For example:
```python
import re

pattern = re .compile('Eggs( and spam)*')

pattern.search('Eggs')
<re.Match object; span=(0, 4), match='Eggs'>

pattern.search('Eggs and spam')
<re.Match object; span=(0, 13), match='Eggs and spam'>

pattern.search('Eggs and spam and spam')
<re.Match object; span=(0, 22), match='Eggs and spam and spam'>

pattern.search('Eggs and spam and spam and spam')
<re.Match object; span=(0, 31), match='Eggs and spam and spam and spam'>
```
While the `'Eggs'` part of the string must appear once, there can be any number of `' and spam'` following it, including zero instances.  If you need to match an actual star character, prefix the star in the regular expression with a backslash, `\*`.

### Matching One or More Qualifiers:
While `*` means “match zero or more,” the `+` (or plus) means “match one or more.” Unlike the star, which does not require its qualifier to appear in the matched string, the plus requires the qualifier preceding it to appear at least once. It is not optional. For example:
```python
pattern = re .compile('Eggs( and spam)+')

pattern.search('Eggs and spam')
<re.Match object; span=(0, 13), match='Eggs and spam'>

pattern.search('Eggs and spam and spam')
<re.Match object; span=(0, 22), match='Eggs and spam and spam'>

pattern.search('Eggs and spam and spam and spam')
<re.Match object; span=(0, 31), match='Eggs and spam and spam and spam'>
```
The regex `'Eggs( and spam)+'` will not match the string `'Eggs'`, because the plus sign requires at least one `' and spam'`. You’ll often use parentheses in your regex strings to group together qualifiers so that a quantifier can apply to the entire group. For example, you could match any combination of dots and dashes of Morse code with `r'(\.|\-)+'` (though this expression would also match invalid Morse code combinations).  

If you need to match an actual plus sign character, prefix the plus sign with a backslash to escape it: `\+`.

### Matching a Specific Number of Qualifiers:
If you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets. For example, the regex `(Ha){3}` will match the string `'HaHaHa'` but not `'HaHa'`, since the latter has only two repeats of the `(Ha)` group.  

Instead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the curly brackets. For example, the regex `(Ha){3,5}` will match `'HaHaHa'`, `'HaHaHaHa'`, and `'HaHaHaHaHa'`.  

You can also leave out the first or second number in the curly brackets to keep the minimum or maximum unbounded. For example, `(Ha){3,}` will match three or more instances of the `(Ha)` group, while `(Ha){,5}` will match zero to five instances. Curly brackets can help make your regular expressions shorter. Hence; `(Ha){3}` = `HaHaHa`, `(Ha){3,5}` = `(HaHaHa)|(HaHaHaHa)|(HaHaHaHaHa)`. For example:
```python
import re

haRegex = re .compile(r'(Ha){3}')

match1 = haRegex.search('HaHaHa')
match1.group() # 'HaHaHa'

match = haRegex.search('HaHa')
match == None # True
```
