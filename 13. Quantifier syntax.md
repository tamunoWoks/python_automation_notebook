##  Quantifier Syntax: How Many Qualifiers to Match
In a regular expression string, quantifiers follow qualifier characters to dictate how many of them to match. For example, in the phone number regex considered earlier, the `{3}` follows the `\d` to match exactly three digits.  

If there is no quantifier following a qualifier, the qualifier must appear exactly once: you can think of `r'\d'` as being the same as `r'\d{1}'`

### Matching an Optional Pattern:
Sometimes you may want to match a pattern only optionally. That is, the regex should match zero or one of the preceding qualifiers. The `?` character flags the preceding qualifier as optional. For example:
```python
import re

pattern = re .compile(r'42! ?')

pattern.search('42!')
<re.Match object; span=(0, 3), match='42!'>

pattern.search('42')
<re.Match object; span=(0, 2), match='42'>
```
The `?` part of the regular expression means that the pattern `!` is optional. So it matches both `42!` (with the exclamation mark) and `42` (without it). The `?` question mark has meaning in regex syntax, but the `!` exclamation mark doesn’t. So `r'42!?'` means `'42'` optionally followed by a `'!'`, but `r'42?!'` means `'4'` optionally followed by `'2'` followed by `'!'`:
```python
import re

pattern = re .compile(r'42 ?!')

pattern.search('42!')
<re.Match object; span=(0, 3), match='42!'>

pattern.search('4!')
<re.Match object; span=(0, 2), match='4!'>

pattern.search('42') == None  # No match
True
```
To make multiple characters optional, place them in a group and put the `?` after the group. In the earlier phone number example, you can use `?` to make the regex look for phone numbers that either do or do not have an area code.
```python
pattern = re .compile(r'(\d{3} -) ?\d{3} -\d{4}')

match1 = pattern.search('My number is 415-555-4242')
match1.group() # '415-555-4242'

match2 = pattern.search('My number is 555-4242')
match2.group() # '555-4242'
```
You can think of the `?` as saying, “Match zero or one of the group preceding this question mark.”. If you need to match an actual question mark character, escape it with `\?`.

### Matching Zero or More Qualifiers:
The `*` (called the star or asterisk) means “match zero or more.” In other words, the qualifier that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. For example:
```python
import re

pattern = re .compile('Eggs( and spam)*')

pattern.search('Eggs')
<re.Match object; span=(0, 4), match='Eggs'>

pattern.search('Eggs and spam')
<re.Match object; span=(0, 13), match='Eggs and spam'>

pattern.search('Eggs and spam and spam')
<re.Match object; span=(0, 22), match='Eggs and spam and spam'>

pattern.search('Eggs and spam and spam and spam')
<re.Match object; span=(0, 31), match='Eggs and spam and spam and spam'>
```
While the `'Eggs'` part of the string must appear once, there can be any number of `' and spam'` following it, including zero instances.  If you need to match an actual star character, prefix the star in the regular expression with a backslash, `\*`.

### Matching One or More Qualifiers:
While `*` means “match zero or more,” the `+` (or plus) means “match one or more.” Unlike the star, which does not require its qualifier to appear in the matched string, the plus requires the qualifier preceding it to appear at least once. It is not optional.
