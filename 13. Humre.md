# Humre: A Module for Human-Readable Regexes
Code is read far more often than it’s written, so it’s important for your code to be readable. But the punctuation-dense syntax of regular expressions can be hard for even experienced programmers to read. To solve this, the third party `Humre` Python module takes the good ideas of verbose mode even further by using human-readable, plain-English names to create readable regex 
code.  

Let’s go back to the `r'\d{3}-\d{3}-\d{4}'` previous phone number example. The functions and constants in Humre can produce the same regex string with plain English:
```python
from humre import *

phone_regex = exactly(3, DIGIT) + '-' + exactly(3, DIGIT) + '-' + exactly(4, DIGIT)
phone_regex # '\\d{3}-\\d{3}-\\d{4}'
```
Humre’s constants (like `DIGIT`) contain strings, and Humre’s functions (like `exactly()`) return strings. Humre doesn’t replace the `re` module. Rather, it produces regex strings that can be passed to `re.compile()`:
```python
import re

pattern = re .compile(phone _regex)
pattern.search('My number is 415-555-4242')
<re.Match object; span=(13, 25), match='415-555-4242'>
```
Humre has constants and functions for each feature of regular expression syntax. You can then concatenate the constants and returned strings like any other string. For example, here are Humre’s constants for the shorthand character classes:
- `DIGIT` and `NONDIGIT` represent `r'\d'` and `r'\D'`, respectively.
- `WORD` and `NONWORD` represent `r'\w'` and `r'\W'`, respectively.
- `WHITESPACE` and `NONWHITESPACE` represent `r'\s'` and `r'\S'`, respectively.

A common source of regex bugs is forgetting which characters need to be escaped. You can use Humre’s constants instead of typing the escaped character yourself. For example, say you want to match a single-digit floating-point number with one digit after the decimal point, like '0.9' or '4.5'. However, if you use the regex string `r'\d.\d'`, you might not realize that the dot matches a period (as in '4.5') but also matches any other character (as in '4A5').  
&nbsp;&nbsp;&nbsp;&nbsp;Instead, use Humre’s `PERIOD` constant, which contains the string `r'\.'`. The expression `DIGIT + PERIOD + DIGIT` evaluates to `r'\d\.\d'` and makes it much more obvious what the regex intends to match.  

The following Humre constants exist for escaped characters:
- `PERIOD`
- `DOLLAR_SIGN`
- `QUESTION_MARK`
- `HASHTAG`
- `AMPERSAND`
- `PIPE`
- `OPEN_PAREN`
- `CLOSE_PAREN`
- `ASTERISK`
- `PLUS`
- `MINUS`
- `OPEN_BRACKET`
- `CLOSE_BRACKET`
- `OPEN_BRACE`
- `CLOSE_BRACE`
- `BACKSLASH`
- `CARET`
- `TILDE`

There are also constants for `NEWLINE`, `TAB`, `QUOTE`, and `DOUBLE_QUOTE`. Back references from `r'\1'` to `r'\99`' are represented as `BACK_1` to `BACK_99`. However, you’ll make the largest readability gains by using Humre’s functions. Tthe table below shows these functions and their equivalent regular expression syntax.
### Humre Functions:
| Humre Function       | Regex String  |
|----------------------|---------------|
| group('A')           | r'(A)'        |
| optional('A')        | r'A?'         |
| either('A', 'B', 'C')| r'A\|B\|C'    |
| exactly(3, 'A')      | 'A{3}'        |
| between(3, 5, 'A')   | 'A{3,5}'      |
| at_least(3, 'A')     | 'A{3,}'       |
| at_most(3, 'A')      | 'A{,3}'       |
| chars('A-Z')         | '[A-Z]'       |
| nonchars('A-Z')      | '[^A-Z]'      |
| zero_or_more('A')    | 'A*'          |
| zero_or_more_lazy('A') | 'A*?'       |
| one_or_more('A')     | 'A+'          |
| one_or_more_lazy('A')| 'A+?'         |
| starts_with('A')     | '^A'          |
| ends_with('A')       | 'A$'          |
| starts_and_ends_with('A') | '^A$'   |
| named_group('name', 'A') | '(?P<name>A)' |

Humre also has several convenience functions that combine common pairs of function calls. For example, instead of using `optional(group('A'))` to `create '(A)?'`, you can simply call `optional_group('A')`. The table below has the full list of Humre convenience functions.
### Humre Convenience Functions:
| Convenience Function          | Function Equivalent              | Regex String |
|-------------------------------|----------------------------------|--------------|
| optional_group('A')           | optional(group('A'))             | '(A)?'       |
| group_either('A')             | group(either('A', 'B', 'C'))     | '(A\|B\|C)'  |
| exactly_group(3, 'A')         | exactly(3, group('A'))           | '(A){3}'     |
| between_group(3, 5, 'A')      | between(3, 5, group('A'))        | '(A){3,5}'   |
| at_least_group(3, 'A')        | at_least(3, group('A'))          | '(A){3,}'    |
| at_most_group(3, 'A')         | at_most(3, group('A'))           | '(A){,3}'    |
| zero_or_more_group('A')       | zero_or_more(group('A'))         | '(A)*'       |
| zero_or_more_lazy_group('A')  | zero_or_more_lazy(group('A'))    | '(A)*?'      |
| one_or_more_group('A')        | one_or_more(group('A'))           | '(A)+'       |
| one_or_more_lazy_group('A')   | one_or_more_lazy(group('A'))     | '(A)+?'      |

All of Humre’s functions except `either()` and `group_either()` allow you to pass multiple strings to automatically join them. This means that calling `group(DIGIT, PERIOD, DIGIT)` produces the same regex string as `group(DIGIT + PERIOD + DIGIT)`. They both return the regex string `r'(\d\.\d)'`.  

Finally, Humre has constants for common regex patterns:
- `ANY_SINGLE`: The `.` pattern that matches any single character (except newlines)
- `ANYTHING_LAZY`: The lazy `.*?` zero or more pattern
- `ANYTHING_GREEDY`: The greedy `.*` zero or more pattern
- `SOMETHING_LAZY`: The lazy `.+?` one or more pattern
- `SOMETHING_GREEDY`: The greedy `.+` one or more pattern

The readability of regex written with Humre becomes more obvious when you consider large, complicated regular expressions. Let’s rewrite the phone number regex from the previous phone number extractor project using Humre:
```python
import re
from humre import *

# Build a human-readable regex for phone numbers
phone_regex = group(
    optional_group(  # Optional area code
        either(
            exactly(3, DIGIT),  # e.g., 415
            OPEN_PAREN + exactly(3, DIGIT) + CLOSE_PAREN  # e.g., (415)
        )
    ),
    optional(group_either(WHITESPACE, '-', PERIOD)),  # Optional separator
    group(exactly(3, DIGIT)),  # First three digits
    group_either(WHITESPACE, '-', PERIOD),  # Separator
    group(exactly(4, DIGIT)),  # Last four digits
    optional_group(  # Optional extension
        zero_or_more(WHITESPACE),
        group_either('ext', 'x', r'ext\.'),
        zero_or_more(WHITESPACE),
        group(between(2, 5, DIGIT))
    )
)

# Compile the pattern
pattern = re.compile(phone_regex)

# Search for a phone number in text
match = pattern.search('My number is 415-555-1212.')

if match:
    print(match.group())
else:
    print("No match found.")
```
When you run this program, the output is this:
> 415-555-1212

This code is much more verbose than even the verbose mode regex. It helps to import `Humre` using the `from humre import * syntax so that you don’t need to put `humre.` before every function and constant. But the length of the code doesn’t matter as much as the readability.
