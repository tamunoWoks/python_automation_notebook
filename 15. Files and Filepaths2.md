### Specifying Absolute vs. Relative Paths
There are two ways to specify a filepath:
- An *absolute path*, which always begins with the root folder (C:\ on Windows and / on macOS and Linux)
- A *relative path*, which is relative to the program’s current working directory.

On Windows, `C:\` is the root for the main hard drive. This lettering dates back to the 1960s, when computers had two floppy disk drives labeled `A:\` and `B:\`. On Windows, USB flash memory and DVD drives are assigned to letters `D:\` and higher. Use one of these drives as the root folder to access files on that storage media.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There are also the *dot* (.) and *dot-dot* (..) folders. These are not real folders but special names that can be used in a filepath. A single period (dot) for a folder name is shorthand for *this folder*. Two periods (dot-dot) means the *parent folder*. The `.\` at the start of a relative path is optional. For example, `.\spam.txt` and `spam.txt` refer to the same file.

### Creating New Folders
Your programs can create new folders with the `os.makedirs()` function.  For example:
```python
import os
os.makedirs('C:\\delicious\\walnut\\waffles')
```
This will create not just the `C:\delicious` folder but also a `walnut` folder inside `C:\delicious` and a `waffles` folder inside `C:\delicious\walnut`. That is, `os.makedirs()` will create any necessary intermediate folders to ensure that the full path exists.  

To make a directory from a `Path` object, call the `mkdir()` method. For example, this code will create a spam folder under the home folder on my computer:
```python
from pathlib import Path
Path(r'C:\Users\Al\spam').mkdir()
```
Note that `mkdir()` can only make one directory at a time; it won’t make several subdirectories at once, like `os.makedirs()` will.

### Handling Absolute and Relative Paths
Calling the `is_absolute()` method on a `Path` object will return `True` if it represents an absolute path or `False` if it represents a relative path. For example, enter the following using your own files and folders instead of the exact ones listed here:
```python
from pathlib import Path

Path.cwd()
# WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python312')

Path.cwd().is_absolute()
# True

Path('spam/bacon/eggs').is_absolute()
# False
```
To get an absolute path from a relative path, you can put `Path.cwd() /` in front of the relative `Path` object. After all, when we say “relative path,” we almost always mean a path that is relative to the current working directory. 
The `absolute()` method also returns this `Path` object. For example:
```python
from pathlib import Path

Path('my/relative/path')
# WindowsPath('my/relative/path')

Path.cwd() / Path('my/relative/path')
# WindowsPath('C:/Users/Al/Desktop/my/relative/path')

Path('my/relative/path').absolute()
# WindowsPath('C:/Users/Al/Desktop/my/relative/path')
```
If your relative path is relative to another path besides the current working directory, replace `Path.cwd()` with that other path. The following example gets an absolute path using the home directory instead of the current working directory:
```python
from pathlib import Path

Path('my/relative/path')
# WindowsPath('my/relative/path')

Path.home() / Path('my/relative/path')
# WindowsPath('C:/Users/Al/my/relative/path')
```
`Path` objects are used to represent both relative and absolute paths. The only difference is whether the `Path object begins with the root folder or not.

### Getting the Parts of a Filepath:
Given a `Path` object, you can extract the filepath’s different parts as strings using several `Path` object attributes. These can be useful for constructing new filepaths based on existing ones.  

 The parts of a filepath include the following:
- The anchor, which is the root folder of the filesystem
- On Windows, the drive, which is the single letter that often denotes a physical hard drive or other storage device
- The parent, which is the folder that contains the file
- The name of the file, made up of the stem (or base name) and the suffix (or extension).

**Note:**  
The Windows Path objects have a `drive` attribute, but macOS and Linux `Path` objects don’t. The `drive` attribute doesn’t include the first backslash.  
Let's extract each attribute from the filepath:
```python
from pathlib import Path

p = Path('C:/Users/Al/spam.txt')

p.anchor # 'C:\\'
p.parent # WindowsPath('C:/Users/Al')
p.name # 'spam.txt'
p.stem # 'spam'
p.suffix # '.txt'
p.drive # 'C:'
```
These attributes evaluate to simple string values, except for ``, which evaluates to another `Path` object. If you want to split up a path by its separator, access the `parts` attribute to get a tuple of string values:
```python
from pathlib import Path

p = Path('C:/Users/Al/spam.txt')

p.parts # ('C:\\', 'Users', 'Al', 'spam.txt')
p.parts[3] # 'spam.txt'
p.parts[0:2] # ('C:\\', 'Users')
```
**Note:**  
Even though the string used in the `Path()` call contains forward slashes, parts uses an anchor on Windows that has the appropriate backslash: `'C:\\'` (or `r'C:\'` as a raw string with the backslash unescaped).  

The `parents` attribute (which is different from the `parent` attribute) evaluates to the ancestor folders of a `Path` object with an integer index:
```python
from pathlib import Path

Path.cwd() # WindowsPath('C:/Users/Al/Desktop')
Path.cwd().parents[0] # WindowsPath('C:/Users/Al')
Path.cwd().parents[1] # WindowsPath('C:/Users')
Path.cwd().parents[2] # WindowsPath('C:/')
```
If you keep following the parent folders, you will end up with the root folder
