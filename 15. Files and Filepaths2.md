### Specifying Absolute vs. Relative Paths
There are two ways to specify a filepath:
- An *absolute path*, which always begins with the root folder (C:\ on Windows and / on macOS and Linux)
- A *relative path*, which is relative to the program’s current working directory.

On Windows, `C:\` is the root for the main hard drive. This lettering dates back to the 1960s, when computers had two floppy disk drives labeled `A:\` and `B:\`. On Windows, USB flash memory and DVD drives are assigned to letters `D:\` and higher. Use one of these drives as the root folder to access files on that storage media.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There are also the *dot* (.) and *dot-dot* (..) folders. These are not real folders but special names that can be used in a filepath. A single period (dot) for a folder name is shorthand for *this folder*. Two periods (dot-dot) means the *parent folder*. The `.\` at the start of a relative path is optional. For example, `.\spam.txt` and `spam.txt` refer to the same file.

### Creating New Folders
Your programs can create new folders with the `os.makedirs()` function.  For example:
```python
import os
os.makedirs('C:\\delicious\\walnut\\waffles')
```
This will create not just the `C:\delicious` folder but also a `walnut` folder inside `C:\delicious` and a `waffles` folder inside `C:\delicious\walnut`. That is, `os.makedirs()` will create any necessary intermediate folders to ensure that the full path exists.  

To make a directory from a `Path` object, call the `mkdir()` method. For example, this code will create a spam folder under the home folder on my computer:
```python
from pathlib import Path
Path(r'C:\Users\Al\spam').mkdir()
```
Note that `mkdir()` can only make one directory at a time; it won’t make several subdirectories at once, like `os.makedirs()` will.

### Handling Absolute and Relative Paths
Calling the `is_absolute()` method on a `Path` object will return `True` if it represents an absolute path or `False` if it represents a relative path. For example, enter the following using your own files and folders instead of the exact ones listed here:
```python
from pathlib import Path

Path.cwd()
# WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python312')

Path.cwd().is_absolute()
# True

Path('spam/bacon/eggs').is_absolute()
# False
```
To get an absolute path from a relative path, you can put `Path.cwd() /` in front of the relative `Path` object. After all, when we say “relative path,” we almost always mean a path that is relative to the current working directory. 
The `absolute()` method also returns this `Path` object. For example:
```python
from pathlib import Path

Path('my/relative/path')
# WindowsPath('my/relative/path')

Path.cwd() / Path('my/relative/path')
# WindowsPath('C:/Users/Al/Desktop/my/relative/path')

Path('my/relative/path').absolute()
# WindowsPath('C:/Users/Al/Desktop/my/relative/path')
```
If your relative path is relative to another path besides the current working directory, replace `Path.cwd()` with that other path. The following example gets an absolute path using the home directory instead of the current working directory:
```python
from pathlib import Path

Path('my/relative/path')
# WindowsPath('my/relative/path')

Path.home() / Path('my/relative/path')
# WindowsPath('C:/Users/Al/my/relative/path')
```
`Path` objects are used to represent both relative and absolute paths. The only difference is whether the `Path object begins with the root folder or not.

### Getting the Parts of a Filepath:
Given a `Path` object, you can extract the filepath’s different parts as strings using several `Path` object attributes. These can be useful for constructing new filepaths based on existing ones.  

 The parts of a filepath include the following:
- The anchor, which is the root folder of the filesystem
- On Windows, the drive, which is the single letter that often denotes a physical hard drive or other storage device
- The parent, which is the folder that contains the file
- The name of the file, made up of the stem (or base name) and the suffix (or extension).

**Note:**  
The Windows Path objects have a `drive` attribute, but macOS and Linux `Path` objects don’t. The `drive` attribute doesn’t include the first backslash.  
Let's extract each attribute from the filepath:
```python
from pathlib import Path

p = Path('C:/Users/Al/spam.txt')

p.anchor # 'C:\\'
p.parent # WindowsPath('C:/Users/Al')
p.name # 'spam.txt'
p.stem # 'spam'
p.suffix # '.txt'
p.drive # 'C:'
```
These attributes evaluate to simple string values, except for ``, which evaluates to another `Path` object. If you want to split up a path by its separator, access the `parts` attribute to get a tuple of string values:
```python
from pathlib import Path

p = Path('C:/Users/Al/spam.txt')

p.parts # ('C:\\', 'Users', 'Al', 'spam.txt')
p.parts[3] # 'spam.txt'
p.parts[0:2] # ('C:\\', 'Users')
```
**Note:**  
Even though the string used in the `Path()` call contains forward slashes, parts uses an anchor on Windows that has the appropriate backslash: `'C:\\'` (or `r'C:\'` as a raw string with the backslash unescaped).  

The `parents` attribute (which is different from the `parent` attribute) evaluates to the ancestor folders of a `Path` object with an integer index:
```python
from pathlib import Path

Path.cwd() # WindowsPath('C:/Users/Al/Desktop')
Path.cwd().parents[0] # WindowsPath('C:/Users/Al')
Path.cwd().parents[1] # WindowsPath('C:/Users')
Path.cwd().parents[2] # WindowsPath('C:/')
```
If you keep following the parent folders, you will end up with the root folder

### Finding File Sizes and Timestamps:
Once you have ways to handle filepaths, you can start gathering information about specific files and folders. The `stat()` method returns a `stat_result` object with file size and timestamp information about a file.  
For example, let's find out about the `calc.exe` program file on Windows:
```python
from pathlib import Path

calc_file = Path('C:/Windows/System32/calc.exe')

calc_file.stat() # os.stat_result(st_mode=33279, st_ino=562949956525418, st_dev=3739257218, st_nlink=2, st_uid=0, st_gid=0, st_size=27648, st_atime=1678984560, st_mtime=1575709787, st_ctime=1575709787)

calc_file.stat().st_size # 27648
calc_file.stat().st_mtime # 1712627129.0906117

import time

time.asctime(time.localtime(calc_file.stat().st_mtime)) # 'Mon Apr  8 20:45:29 2024'
```
The `st_size` attribute of the `stat_result` object returned by the `stat()` method is the size of the file in bytes. You can divide this integer by 1024, by 1024 ** 2, or by 1024 ** 3 to get the size in KB, MB, or GB, respectively.  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The `st_mtime` is the “last modified” timestamp, which can be useful for figuring out the last time a `.docx` Word file was changed. This timestamp is in Unix epoch time, which is the number of seconds since January 1, 1970. The `time` module has functions for turning this number into a human-readable form.  

The `stat_result` object has several useful attributes:  
- **st_size:** The size of the file in bytes.  
- **st_mtime:** The “last modified” timestamp, when the file was last changed.  
- **st_ctime:** The “creation” timestamp. On Windows, this identifies when the file was created. On macOS and Linux, this identifies the last time the file’s metadata (such as its name) was changed.  
- **st_atime:** The “last accessed” timestamp, when the file was last read.  

Keep in mind that the modified, creation, and access timestamps can be changed manually, and are not guaranteed to be accurate.

### Finding Files Using Glob Patterns:
The `*` and `?` characters can be used to match folder names and filenames in what are called *glob patterns*. Glob patterns are like a simplified regex language: the `*` character matches any text, and the `?` character matches exactly one character. For example, look at these glob patterns:
- `'*.txt'` matches all files that end with `.txt.`
- `'project?.txt'` matches `'project1.txt'`, `'project2.txt'`, or `'projectX.txt'`.
- `'*project?.*'` matches `'catproject5.txt'` or `'secret_project7.docx'`.
- `'*'` matches all filenames.

`Path` objects of folders have a `glob()` method for listing any content in the folder that matches the glob pattern. The `glob()` method returns a generator object that you’ll need to pass to `list()` :
```python
from pathlib import Path

p = Path('C:/Users/Al/Desktop')

p.glob('*') # <generator object Path.glob at 0x000002A6E389DED0>
list(p.glob('*')) # [WindowsPath('C:/Users/Al/Desktop/1.png'), WindowsPath('C:/Users/Al/ Desktop/22-ap.pdf'), WindowsPath('C:/Users/Al/Desktop/cat.jpg'), WindowsPath('C:/Users/Al/Desktop/zzz.txt')]
```
You can also use the generator object that glob() returns in a for loop:
```python
from pathlib import Path

for name in Path('C:/Users/Al/Desktop').glob('*'):
    print(name)

C:\Users\Al\Desktop\1.png
C:\Users\Al\Desktop\22-ap.pdf
C:\Users\Al\Desktop\cat.jpg
C:\Users\Al\Desktop\zzz.txt
```
